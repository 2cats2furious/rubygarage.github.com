<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta charset="utf-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
      <title>Models</title>
      <link href="assets/models.css" rel="stylesheet" />
      <script src="assets/models.js"></script>
   </head>
   <body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->
<section id="topic" class="slide"><div class="vcenter">
    <h1>Active Record Models</h1>
    <div class="about">
      <p><strong>Active Record</strong> is the <strong>M</strong> in <a href="http://en.wikipedia.org/wiki/Model–view–controller" target="_blank">MVC</a> - the model - which is the layer of the system responsible for representing business data and logic. It is an implementation of <a href="http://en.wikipedia.org/wiki/Active_record_pattern" target="_blank">the Active Record pattern</a> which itself is a description of an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">Object Relational Mapping</a> (ORM) system.</p>
      <p>Active Record gives us several mechanisms, the most important being the ability to:</p>
      <ul><li>Represent models and their data</li>
        <li>Represent associations between these models</li>
        <li>Represent inheritance hierarchies through related models</li>
        <li>Validate models before they get persisted to the database</li>
        <li>Perform database operations in an object-oriented fashion</li>
      </ul></div>
  </div>
</section><section id="models-generation" class="slide"><h2>Models generation</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails generate model User first_name:string email:string password:string
     invoke  active_record
     create    db/migrate/20160410131731_create_users.rb
     create    app/models/user.rb
     invoke    test_unit
     create      test/models/user_test.rb
     create      test/fixtures/users.yml
  ]]></script><h3>Naming Conventions</h3>
  <ul><li>Database Table - Plural with underscores separating words (e.g., book_clubs)</li>
    <li>Model Class - Singular with the first letter of each word capitalized (e.g., BookClub)</li>
  </ul><table class="naming-conventions"><thead><tr><th>Model / Class</th>
        <th>Table / Schema</th>
      </tr></thead><tbody><tr><td><code>Post</code></td>
        <td><code>posts</code></td>
      </tr><tr><td><code>LineItem</code></td>
        <td><code>line_items</code></td>
      </tr><tr><td><code>Deer</code></td>
        <td><code>deer</code></td>
      </tr><tr><td><code>Mouse</code></td>
        <td><code>mice</code></td>
      </tr><tr><td><code>Person</code></td>
        <td><code>people</code></td>
      </tr></tbody></table></section><section id="migrations-topic" class="slide"><div class="vcenter">
    <h1>Active Record Migrations</h1>
    <div class="about">
      <p><strong>Migrations</strong> are a feature of Active Record that allows you to evolve your database schema over time. Rather than write schema modifications in pure SQL, migrations allow you to use an easy Ruby DSL to describe changes to your tables.</p>
    </div>
  </div>
</section><section id="migrations" class="slide"><h2>Overview</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class CreateUsers < ActiveRecord::Migration[5.0]
        def change
          create_table :users do |t|
            t.string :first_name
            t.string :email
            t.string :password

            t.timestamps
          end
        end
      end
  ]]></script><h3>Schema Conventions</h3>
  <ul><li><strong>Foreign keys</strong> - These fields should be named following the pattern singularized_table_name_id (e.g., item_id, order_id). These are the fields that Active Record will look for when you create associations between your models.</li>
    <li><strong>Primary keys</strong> - By default, Active Record will use an integer column named id as the table's primary key. When using Rails Migrations to create your tables, this column will be automatically created.</li>
    <li><strong>created_at</strong> - Automatically gets set to the current date and time when the record is first created.</li>
    <li><strong>updated_at</strong> - Automatically gets set to the current date and time whenever the record is updated.</li>
    <li><strong>lock_version</strong> - Adds optimistic locking to a model.</li>
    <li><strong>type</strong> - Specifies that the model uses Single Table Inheritance.</li>
    <li><strong>(association_name)_type</strong> - Stores the type for polymorphic associations.</li>
    <li><strong>(table_name)_count</strong> - Used to cache the number of belonging objects on associations. For example, a comments_count column in a Post class that has many instances of Comment will cache the number of existent comments for each post.</li>
  </ul></section><section id="add-migrations" class="slide"><h2>Add Migrations</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddLastNameToUsers last_name:string:index
      invoke  active_record
      create    db/migrate/20160410133524_add_last_name_to_users.rb

  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    YYYYMMDDHHMMSS UTC timestamp
    20160410133524_add_last_name_to_users.rb
  ]]></script><h3>Change</h3>
  db/migrate/20160410133524_add_last_name_to_users.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     class AddLastNameToUsers < ActiveRecord::Migration[5.0]
      def change
        add_column :users, :last_name, :string
        add_index :users, :last_name
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddReceiveNewsToUsers receive_news:boolean
      invoke  active_record
      create    db/migrate/20160410133746_add_receive_news_to_users.rb
  ]]></script>

  db/migrate/20160410133746_add_receive_news_to_users.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class AddReceiveNewsToUsers < ActiveRecord::Migration[5.0]
      def change
        add_column :users, :receive_news, :boolean
      end
    end
  ]]></script><h3>Up and down (old style)</h3>
  db/migrate/20160410133746_add_receive_news_to_users.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class AddReceiveNewsToUsers < ActiveRecord::Migration[5.0]
      def up
        change_table :users do |t|
          t.boolean :receive_news, default: true
          t.index :receive_news
        end

        User.update_all ["receive_news = ?", true]
      end

      def down
        remove_column :users, :receive_news
      end
    end
  ]]></script><h3>Reversible</h3>
  db/migrate/20160410133746_change_user_number.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class ChangeUsersNumber < ActiveRecord::Migration[5.0]
      def change
        reversible do |dir|
          change_table :users do |t|
            dir.up   { t.change :user_number, :string }
            dir.down { t.change :user_number, :integer }
          end
        end
      end
    end

    class ChangeUsersNumber < ActiveRecord::Migration[5.0]
      def up
        change_table :users do |t|
          t.change :user_number, :string
        end
      end

      def down
        change_table :users do |t|
          t.change :user_number, :integer
        end
      end
    end
  ]]></script><p>
    If your migration is irreversible, you should raise ActiveRecord::IrreversibleMigration from your down method.
    If someone tries to revert your migration, an error message will be displayed saying that it can't be done.
  </p>
</section><section id="reverse-previous-migration" class="slide"><h2>Reverse previous migration</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    require_relative '20160410133746_change_user_number'

    class FixupChangeUserNumberMigration < ActiveRecord::Migration[5.0]
      def change
       revert ChangeUsersNumber

       create_table(:users) do |t|
         t.string :variety
       end
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class FixupChangeUserNumberMigration < ActiveRecord::Migration[5.0]
      def change
        revert do
          # copy-pasted code from ChangeUsersNumber
          reversible do |dir|
            change_table :users do |t|
              dir.up   { t.change :user_number, :string }
              dir.down { t.change :user_number, :integer }
            end
          end

          # The rest of the migration was ok
        end
      end
   end
  ]]></script></section><section id="db-changing-methods" class="slide"><h2>Methods for db structure changing</h2>

  <code>create_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    create_table :friends do |t|
      t.string :first_name
      t.string :last_name
      t.string :email
      t.timestamps
    end
  ]]></script><code>change_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    change_table :friends do |t|
      t.remove :last_name, :first_name
      t.string :phone_number
      t.index  :phone_number
    end
  ]]></script><code>add_column</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    add_column :friends, :first_name, :string
    add_column :friends, :last_name, :integer
  ]]></script><code>add_foreign_key</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    #If the column names can not be derived from the table names, use the :column and :primary_key options.
    add_foreign_key :friends, :users
  ]]></script><code>change_column</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    change_column :friends, :last_name, :string
  ]]></script><code>change_column_null</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    change_column_null :users, :receive_news, false
  ]]></script><code>change_column_default</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    change_column_default :users, :receive_news, from: true, to: false
  ]]></script><code>create_join_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    create_join_table :users, :friends do |t|
       # t.index [:user_id, :friend_id]
       # t.index [:friend_id, :user_id]
    end
  ]]></script><code>drop_join_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    drop_join_table :users, :friends
  ]]></script><code>rename_column</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    rename_column :friends, :last_name, :surname
  ]]></script><code>remove_column</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    remove_column :friends, :surname
  ]]></script><code>add_index</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    add_index :friends, :email
  ]]></script><code>add_reference</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    add_reference :friends, :user, index: true, foreign_key: true
  ]]></script><code>add_timestamps</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    add_timestamps :users
  ]]></script><code>remove_index</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    remove_index :friends, :email
  ]]></script><code>drop_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    drop_table :friends
  ]]></script><code>enable_extension</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    enable_extension "hstore"
  ]]></script><code>disable_extension</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    disable_extension "hstore"
  ]]></script><code>remove_foreign_key</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     remove_foreign_key :users, :friends
     remove_foreign_key :users, column: :my_friend_id
     remove_foreign_key :users, name: :special_fk_name
  ]]></script><code>remove_reference</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     remove_reference :users, :client
  ]]></script><code>remove_timestamps</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     remove_timestamps :users
  ]]></script><code>rename_index</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     rename_index :users, :index_first_name, :index_first_user_name
  ]]></script><code>rename_table</code>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     rename_table :users, :customers
  ]]></script></section><section id="column-types" class="slide"><h2>Column Types</h2>
  <ul><li><code>:binary</code></li>
    <li><code>:boolean</code></li>
    <li><code>:date</code></li>
    <li><code>:datetime</code></li>
    <li><code>:decimal</code></li>
    <li><code>:float</code></li>
    <li><code>:integer</code></li>
    <li><code>:primary_key</code></li>
    <li><code>:string</code></li>
    <li><code>:text</code></li>
    <li><code>:time</code></li>
    <li><code>:timestamp</code></li>
    <li><code>:references</code></li>
  </ul></section><section id="example-migration" class="slide"><h2>Example Migration</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class ExampleMigration < ActiveRecord::Migration
      def up
        create_table :users do |t|
          t.references :group
        end
        #add a foreign key
        execute <<-SQL
          ALTER TABLE products
            ADD CONSTRAINT fk_users_groups
            FOREIGN KEY (group_id)
            REFERENCES groups(id)
        SQL
        add_column :users, :home_page_url, :string
        rename_column :users, :email, :email_address
      end

      def down
        rename_column :users, :email_address, :email
        remove_column :users, :home_page_url
        execute <<-SQL
          ALTER TABLE users
            DROP FOREIGN KEY fk_users_groups
        SQL
        drop_table :users
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class ExampleMigration < ActiveRecord::Migration[5.0]
      def change
        create_table :distributors do |t|
          t.string :zipcode
        end

        reversible do |dir|
          dir.up do
            # add a CHECK constraint
            execute <<-SQL
              ALTER TABLE distributors
                ADD CONSTRAINT zipchk
                  CHECK (char_length(zipcode) = 5) NO INHERIT;
            SQL
          end
          dir.down do
            execute <<-SQL
              ALTER TABLE distributors
                DROP CONSTRAINT zipchk
            SQL
          end
        end

        add_column :users, :home_page_url, :string
        rename_column :users, :email, :email_address
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    require_relative '20121212123456_example_migration'

    class FixupExampleMigration < ActiveRecord::Migration[5.0]
      def change
        revert ExampleMigration

        create_table(:apples) do |t|
          t.string :variety
        end
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[5.0]
      def change
        revert do
          # copy-pasted code from ExampleMigration
          reversible do |dir|
            dir.up do
              # add a CHECK constraint
              execute <<-SQL
                ALTER TABLE distributors
                  ADD CONSTRAINT zipchk
                    CHECK (char_length(zipcode) = 5);
              SQL
            end
            dir.down do
              execute <<-SQL
                ALTER TABLE distributors
                  DROP CONSTRAINT zipchk
              SQL
            end
          end

          # The rest of the migration was ok
        end
      end
    end
  ]]></script></section><section id="running-migrations" class="slide"><h2>Run run run ruuuuuuuuun</h2>
  <h3>Running Migrations</h3>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
        bin/rails db:migrate
  ]]></script><h3>Rollback Migrations</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
        bin/rails db:rollback
        bin/rails db:rollback STEP=3
        bin/rails db:migrate:down VERSION=20160410211749
        bin/rails db:migrate:up VERSION=20160410211749
        bin/rails db:migrate:redo STEP=3
  ]]></script></section><section id="topic-active-record-objects" class="slide"><div class="vcenter">
    <h1>Active Record Objects</h1>
  </div>
</section><section id="activerecord-functions" class="slide"><h2>ActiveRecord functions</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails c  # rails console
  ]]></script><h3>new</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user = User.new
      => #<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false >]
  ]]></script><h3>save</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.first_name = "Anna"
      => "Anna"

    > user.email = "happy_ann@gmail.com"
      => "happy_ann@gmail.com"

    > user.save
      INSERT INTO "users" ("created_at", "email", "first_name", "last_name", "password", "receive_news", "updated_at") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Sun, 10 Apr 2016 19:00:01 UTC +00:00], ["email", "happy_ann@gmail.com"], ["first_name", "Anna"], ["last_name", nil], ["password", nil], ["receive_news", false], ["updated_at", Sun, 10 Apr 2016 19:00:01 UTC +00:00]]
      => true
  ]]></script><h3>all</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.all
      SELECT "users".* FROM "users"
      => #<ActiveRecord::Relation [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2016-04-10 19:00:01", updated_at: "2016-04-10 19:00:01", receive_news: nil, last_name: nil>]>
  ]]></script><h3>Rails 3</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.all.class
      SELECT "users".* FROM "users"
    => Array

  ]]></script><h3>Rails 4</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.all.class
    => ActiveRecord::Relation
  ]]></script></section><section id="activerecord-functions-part2" class="slide"><h2>ActiveRecord functions</h2>
  <h3>create</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > new_user = User.create(first_name: "Ivan", email: "ivan.melechov@gmail.com")

    (0.1ms)  begin transaction
    SQL (1.5ms)  INSERT INTO "users" ("first_name", "email", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["first_name", "Ivan"], ["email", "ivan.melechov@gmail.com"], ["created_at", 2016-04-10 19:09:42 UTC], ["updated_at", 2016-04-10 19:09:42 UTC]]
    (0.8ms)  commit transaction
    => #<User id: 2, first_name: "Ivan", email: "ivan.melechov@gmail.com", password: nil, created_at: "2016-04-10 19:09:42", updated_at: "2016-04-10 19:09:42", receive_news: nil, last_name: nil>  ]]></script><h3>count</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.count

      SELECT COUNT(*) FROM "users"

      => 2
  ]]></script><h3>update</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > new_user.update(first_name: "Van'ka", email: "vanka@yandex.ru")

    (0.1ms)  begin transaction
    SQL (0.4ms)  UPDATE "users" SET "first_name" = ?, "email" = ?, "updated_at" = ? WHERE "users"."id" = ?  [["first_name", "Van'ka"], ["email", "vanka@yandex.ru"], ["updated_at", 2016-04-10 19:11:53 UTC], ["id", 2]]
     (0.7ms)  commit transaction
    => true
  ]]></script></section><section id="topic-associations" class="slide"><div class="vcenter">
    <h1>Active Record Associations</h1>
  </div>
</section><section id="belongs-to" class="slide"><h2>belongs_to</h2>
  <img src="/public/models/assets/belongs_to.png" /></section><section id="belongs-to-in-model" class="slide"><h2>belongs_to</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g migration AddUserRefToPosts user:references
      invoke  active_record
      create    db/migrate/20160410164224_add_user_ref_to_posts.rb
  ]]></script>

  db/migrate/20160410164224_add_user_ref_to_posts.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class AddUserRefToPosts < ActiveRecord::Migration[5.0]
        def change
          add_reference :posts, :user, index: true
        end
      end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      rake db:migrate
      ==  AddUserRefToPosts: migrating ==============================================
      -- add_reference(:posts, :user, {:index=>true})
      ==  AddUserRefToPosts: migrated (0.0054s) =====================================
  ]]></script>

  app/models/post.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      belongs_to :user
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user = User.first

      SELECT "users".* FROM "users" LIMIT 1

      => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2016-04-10 16:53:04", updated_at: "2016-04-10 16:53:04", last_name: nil, receive_news: false>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post = Post.create(text: "I'm so happy today", title: "So happy", user_id: user.id)

      INSERT INTO "posts" ("created_at", "text", "title", "updated_at", "user_id") VALUES (?, ?, ?, ?)  [["created_at", Sun, 10 Apr 2016 16:55:11 UTC +00:00], ["text", "I'm so happy today"], "So happy", ["updated_at",Sun, 10 Apr 2016 16:55:11 UTC +00:00], ["user_id", 1]]
      (126.0ms)  commit transaction

      => #<Post id: 1, text: "I'm so happy today", title: "So happy", user_id: 1, created_at: "2016-04-10 16:55:11", updated_at: "2016-06-02 16:55:11">
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post.user

      SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1

      => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2016-04-10 16:55:11", updated_at: "2016-04-10 16:55:11", last_name: nil, receive_news: false>
  ]]></script><p> From Rails 5 on every Rails application will have a new configuration option </p>
  <code>config.active_record.belongs_to_required_by_default = true</code>
  <p>, it will trigger a validation error when trying to save a model where belongs_to associations are not present.</p>
  <p>or</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     belongs_to :user, optional: true
  ]]></script></section><section id="has-many" class="slide"><h2>has_many</h2>
  <img src="/public/models/assets/has_many.png" /></section><section id="has_many_in_model" class="slide"><h2>has_many</h2>

  app/models/user.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      has_many :posts
    end
  ]]></script><h3>Get</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.posts

      SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = 1

      => [#<Post id: 1, text: "I'm so happy today", title: "So happy", user_id: 1, created_at: "2016-04-10 16:55:11", updated_at: "2016-04-10 16:55:11">]
  ]]></script><h3>Create</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.posts << Post.new(text: "I'm waiting")

      INSERT INTO "posts" ("created_at", "text",  "updated_at", "user_id") VALUES (?, ?, ?, ?)  [["created_at", Sun, 10 Apr 2016 19:20:23 UTC +00:00], ["text", "I'm waiting"], ["updated_at", Sun, 10 Apr 2016 19:20:23 UTC +00:00], ["user_id", 1]]

      => [#<Post id: 1, text: "I'm so happy today", title: "So happy", user_id: 1, created_at: "2016-04-10 16:55:11", updated_at: "2016-04-10 16:55:11">, #<Post id: 2, text: "I'm waiting", title: nil, user_id: 1, created_at: "2016-04-10 19:20:23", updated_at: "2016-04-10 19:20:23">]
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.posts.create(text: "New post")

      INSERT INTO "posts" ("created_at", "text","updated_at", "user_id") VALUES (?, ?, ?, ?)  [["created_at", Sun, 10 Jun 2016 19:25:27 UTC +00:00], ["text", "New post"], ["updated_at", Sun, 10 Jun 2016 19:25:27 UTC +00:00], ["user_id", 1]]

      => #<Post id: 3, text: "New post", title: nil, user_id: 1, created_at: "2016-04-10 19:25:27", updated_at: "2016-04-10 19:25:27">
  ]]></script><h3>Count</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.posts.count

      SELECT COUNT(*) FROM "posts" WHERE "posts"."user_id" = 1

      => 2
  ]]></script></section><section id="has-one" class="slide"><h2>has_one</h2>
  <img src="/public/models/assets/has_one.png" /></section><section id="has-one-in-model" class="slide"><h2>has_one</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g model PostInfo post_id:integer views:integer likes:integer rating:integer
  ]]></script>

  app/models/post_info.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class PostInfo < ApplicationRecord
      belongs_to :post
    end
  ]]></script>

  app/models/post.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      belongs_to :user
      has_one :post_info
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post = Post.first

      SELECT "posts".* FROM "posts" LIMIT 1

      => #<Post id: 1, text: "I'm so happy today", user_id: 1, created_at: "2016-04-10 16:55:11", updated_at: "2016-04-10 16:55:11">
  ]]></script><h3>Creation PostInfo</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > PostInfo.create(post_id: post.id, views: 40, likes: 5, rating: 10)

      INSERT INTO "post_infos" ("created_at", "likes", "post_id", "rating", "updated_at", "views") VALUES (?, ?, ?, ?, ?, ?)  [["created_at", Sun, 10 Apr 2016 19:50:10 UTC +00:00], ["likes", 5], ["post_id", 1], ["rating", 10], ["updated_at", Sun, 10 Apr 2016 19:50:10 UTC +00:00], ["views", 40]]

      => #<PostInfo id: 2, post_id: 1, views: 40, likes: 5, rating: 10, created_at: "2016-04-10 19:50:10", updated_at: "2016-04-10 19:50:10">
  ]]></script><h3>Getting using the association</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post.post_info

      SELECT "post_infos".* FROM "post_infos" WHERE "post_infos"."post_id" = 1 LIMIT 1

      => #<PostInfo id: 1, post_id: 1, views: 40, likes: 5, rating: 10, created_at: "2016-04-10 19:50:10", updated_at: "2016-04-10 19:50:10">
  ]]></script><h3>Creation using the association</h3>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post.create_post_info(views: 40, likes: 5, rating: 10)

      INSERT INTO "post_infos" ("created_at", "likes", "post_id", "rating", "updated_at", "views") VALUES (?, ?, ?, ?, ?, ?)  [["created_at", Sun, 10 Apr 2016 19:50:10 UTC +00:00], ["likes", 5], ["post_id", 1], ["rating", 10], ["updated_at", Sun, 10 Apr 2016 19:50:10 UTC +00:00], ["views", 40]]

      => #<PostInfo id: 1, post_id: 1, views: 40, likes: 5, rating: 10, created_at: "2016-04-10 19:50:10", updated_at: "2016-04-10 19:50:10">
  ]]></script></section><section id="has-many-through" class="slide"><h2>has_many :through</h2>
  <img src="/public/models/assets/has_many_through.png" /></section><section id="has-many-through-in-model" class="slide"><h2>has_many :through</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g model Blog title:string description:text
      invoke  active_record
      create    db/migrate/20160410194224_create_blogs.rb
      create    app/models/blog.rb
      invoke    test_unit
      create      test/models/blog_test.rb
      create      test/fixtures/blogs.yml
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g model Subscription user:belongs_to blog:belongs_to receive_news:boolean
      invoke  active_record
      create    db/migrate/20160410194832_create_subscriptions.rb
      create    app/models/subscription.rb
      invoke    test_unit
      create      test/models/subscription_test.rb
      create      test/fixtures/subscriptions.yml
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g migration AddBlogRefToPosts blog:references
      invoke  active_record
      create    db/migrate/20160410195621_add_blog_ref_to_posts.rb
  ]]></script>

  db/migrate/20160410194224_create_blogs.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class CreateBlogs < ActiveRecord::Migration[5.0]
        def change
          create_table :blogs do |t|
            t.string :title
            t.text :description

            t.timestamps
          end
        end
      end
  ]]></script>

  db/migrate/20160410194832_create_subscriptions.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class CreateSubscriptions < ActiveRecord::Migration[5.0]
        def change
          create_table :subscriptions do |t|
            t.belongs_to :user, index: true
            t.belongs_to :blog, index: true
            t.boolean :receive_news, default: true

            t.timestamps
          end
        end
      end
  ]]></script>

  db/migrate/20160410195621_add_blog_ref_to_posts.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class AddBlogRefToPosts < ActiveRecord::Migration[5.0]
        def change
          add_reference :posts, :blog, index: true
        end
      end
  ]]></script>

  app/models/user.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class User < ApplicationRecord
        has_many :posts
        has_many :subscriptions
        has_many :blogs, through: :subscriptions
      end
  ]]></script>

  app/models/blog.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Blog < ApplicationRecord
        has_many :subscriptions
        has_many :users, through: :subscriptions
      end
  ]]></script>

  app/models/subscription.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Subscription < ApplicationRecord
        belongs_to :user
        belongs_to :blog
      end
  ]]></script>

  app/models/post.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Post < ApplicationRecord
        belongs_to :user
        belongs_to :blog
        has_one :post_info
      end
  ]]></script></section><section id="has-one-through" class="slide"><h2>has_one :through</h2>
  <img src="/public/models/assets/has_one_through.png" /></section><section id="has-one-through-in-model" class="slide"><h2>has_one :through</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g model Plan name:string description:text price:decimal{8.2}
      invoke  active_record
      create    db/migrate/20160410202622_create_plans.rb
      create    app/models/plan.rb
      invoke    test_unit
      create      test/models/plan_test.rb
      create      test/fixtures/plans.yml
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g model UserPlan user:belongs_to plan:belongs_to
      invoke  active_record
      create    db/migrate/20160410203824_create_user_plans.rb
      create    app/models/user_plan.rb
      invoke    test_unit
      create      test/models/user_plan_test.rb
      create      test/fixtures/user_plans.yml
  ]]></script>

  db/migrate/20160410202622_create_plans.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class CreatePlans < ActiveRecord::Migration[5.0]
      def change
        create_table :plans do |t|
          t.string :name
          t.text :description
          t.decimal :price, precision: 8, scale: 2

          t.timestamps
        end
      end
    end
  ]]></script>


  db/migrate/20160410203824_create_user_plans.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class CreateUserPlans < ActiveRecord::Migration[5.0]
      def change
        create_table :user_plans do |t|
          t.belongs_to :user, index: true
          t.belongs_to :plan, index: true

          t.timestamps
        end
      end
    end
  ]]></script>

  app/models/user.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      has_many :posts
      has_many :subscriptions
      has_many :blogs, through: :subscriptions
      has_one :user_plan
      has_one :plan, through: :user_plan
    end
  ]]></script>

  app/models/user_plan.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class UserPlan < ApplicationRecord
      belongs_to :user
      belongs_to :plan
    end
  ]]></script>

  app/models/plan.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Plan < ApplicationRecord
      has_many :user_plans
      has_many :users, through: :user_plans
    end
  ]]></script></section><section id="has_and_belongs_to_many" class="slide"><h2>has_and_belongs_to_many</h2>
  <img src="/public/models/assets/has_and_belongs_to_many.png" /></section><section id="habtm-in-model" class="slide"><h2>has_and_belongs_to_many</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g model Tag name:string
      invoke  active_record
      create    db/migrate/20160414211322_create_tags.rb
      create    app/models/tag.rb
      invoke    test_unit
      create      test/models/tag_test.rb
      create      test/fixtures/tags.yml
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration create_posts_tags post:references tag:references --no-timestamp
      invoke  active_record
      create    db/migrate/20160414213342_create_posts_tags.rb
  ]]></script><h3>Rails 4</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    create_join_table :posts, :tags
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    create_join_table :posts, :tags, table_name: :tags_for_posts
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    create_join_table :posts, :tags, column_options:  {null:  true}
  ]]></script>

  db/migrate/20160414213342_create_posts_tags.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class CreatePostsTags < ActiveRecord::Migration[5.0]
      def change
        create_table :posts_tags do |t|
          t.references :post, index: true
          t.references :tag, index: true
        end
      end
    end
  ]]></script><h4>Change migration. Add common index and remove id.</h4>
  db/migrate/20160414213342_create_posts_tags.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class CreatePostsTags < ActiveRecord::Migration[5.0]
      def change
        create_table :posts_tags, id: false do |t|
          t.references :post, index: true
          t.references :tag, index: true
        end
        add_index :posts_tags, [:post_id, :tag_id]
      end
    end
  ]]></script>

  app/models/post.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Post < ApplicationRecord
        belongs_to :user
        has_and_belongs_to_many :tags
      end
  ]]></script>

  app/models/tag.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Tag < ApplicationRecord
      has_and_belongs_to_many :posts
    end
]]></script></section><section id="polymorphic" class="slide"><h2>Polymorphic Associations</h2>
  <img src="/public/models/assets/polymorphic.png" /></section><section id="polymorphic-in-model" class="slide"><h2>Polymorphic Assosiations</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g model Picture imageable:references{polymorphic} file:string
      invoke  active_record
      create    db/migrate/20160414231322_create_pictures.rb
      create    app/models/picture.rb
      invoke    test_unit
      create      test/models/picture_test.rb
      create      test/fixtures/pictures.yml
  ]]></script>

  db/migrate/20160414231322_create_pictures.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class CreatePictures < ActiveRecord::Migration[5.0]
      def change
        create_table :pictures do |t|
          t.references :imageable, polymorphic: true, index: true
          t.string :file

          t.timestamps
        end
      end
    end
  ]]></script>

  app/models/picture.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Picture < ApplicationRecord
      belongs_to :imageable, polymorphic: true
    end
  ]]></script>

  app/models/user.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      has_many :posts
      has_many :subscriptions
      has_many :blogs, through: :subscriptions
      has_one :user_plan
      has_one :plan, through: :user_plan
      has_one :picture, as: :imageable
    end
  ]]></script>

  app/models/post.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      belongs_to :user
      belongs_to :blog
      has_one :post_info
      has_and_belongs_to_many :tags
      has_many :pictures, as: :imageable
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user.create_picture(file: 'public/picture/photo.png')

      INSERT INTO "pictures" ("created_at", "file", "imageable_id", "imageable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Fri, 15 Apr 2016 17:35:01 UTC +00:00], ["file", "public/picture/photo.png"], ["imageable_id", 1], ["imageable_type", "User"], ["updated_at", Fri, 15 Apr 2016 17:35:01 UTC +00:00]]

      => #<Picture id: 1, imageable_id: 1, imageable_type: "User", file: "public/picture/photo.png", created_at: "2016-04-15 17:35:01", updated_at: "2016-04-15 17:35:01">
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > post.pictures.create(file: 'public/picture/image.png')

      INSERT INTO "pictures" ("created_at", "file", "imageable_id", "imageable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Fri, 15 Apr 2016 17:45:21 UTC +00:00], ["file", "public/picture/image.png"], ["imageable_id", 1], ["imageable_type", "Post"], ["updated_at", Fri, 15 Apr 2016 17:45:21 UTC +00:00]]

      => #<Picture id: 2, imageable_id: 1, imageable_type: "Post", file: "public/picture/image.png", created_at: "2016-04-15 17:45:21", updated_at: "2016-04-15 17:45:21">
  ]]></script></section><section id="topic-validations" class="slide"><div class="vcenter">
    <h1>Active Record Validations</h1>
  </div>
</section><section id="when-do-validation-happen" class="slide"><h2>When Do Validations Happen?</h2>
  <ul><li><code>create</code></li>
    <li><code>create!</code></li>
    <li><code>save</code></li>
    <li><code>save!</code></li>
    <li><code>update</code></li>
    <li><code>update!</code></li>
  </ul><h2>Skiping Validations</h2>
  <ul><li><code>decrement!</code></li>
    <li><code>decrement_counter</code></li>
    <li><code>increment!</code></li>
    <li><code>increment_counter</code></li>
    <li><code>toggle!</code></li>
    <li><code>touch</code></li>
    <li><code>update_all</code></li>
    <li><code>update_attribute</code></li>
    <li><code>update_column</code></li>
    <li><code>update_columns</code></li>
    <li><code>update_counters</code></li>
  </ul><code>save(validate: false)</code>
</section><section id="valid-invalid" class="slide"><h2>valid? and invalid?</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      has_many :posts
      validates :email, presence: true
    end
  ]]></script><h3>valid?</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > User.new(email: "thebestemail@ua.fm").valid?
      => true

    > User.new().valid?
      => false
  ]]></script><h3>Get errors</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > u = User.new
      => #<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>

    > u.errors
      => #<ActiveModel::Errors:0x00000003001970 @base=#<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>, @messages={}>

    > u.valid?
      => false

    > u.errors
      => #<ActiveModel::Errors:0x00000003001970 @base=#<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>, @messages={:email=>["can't be blank"]}>
  ]]></script><h3>On create</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > u = User.create
      => #<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>

    > u.errors
      => #<ActiveModel::Errors:0x00000003172db8 @base=#<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>, @messages={:email=>["can't be blank"]}>
  ]]></script><h3>On create!</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > User.create!
      ActiveRecord::RecordInvalid: Validation failed: Email cant be blank
  ]]></script><h3>On save and save!</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > u = User.new
      => #<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>

    > u.save
      => false

    > u.save!
      ActiveRecord::RecordInvalid: Validation failed: Email cant be blank
  ]]></script></section><section id="errors" class="slide"><h2>errors[]</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > User.new.errors[:email].any?
      => false

    > User.create.errors[:email].any?
      => true

    > User.create.errors.messages
      => {email:["can't be blank"]}

    > User.create.errors.details[:email]
      =>  [{error: :blank}]

    > User.create.errors.full_messages
      => ["Email can't be blank"]
  ]]></script></section><section id="presence" class="slide"><h2>Presence</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      attr_accessible :email, :first_name, :password

      has_many :posts
      validates :email, :first_name, presence: true
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Post < ApplicationRecord

        belongs_to :user
        validates :user, presence: true
      end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      attr_accessible :email, :first_name, :password

      has_many :posts, inverse_of: :user
    end
  ]]></script><p>
    Can be used for the presence of an object associated validation via a has_one or has_many relationship,
    it will check that the object is neither <code>blank?</code> nor <code>marked_for_destruction?</code>.
  </p>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    validates :field_name, inclusion: { in:  [true, false] }. # for fields with boolean type
  ]]></script></section><section id="absence" class="slide"><h2>Presence</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      attr_accessible :email, :first_name, :password

      has_many :posts
      validates :archived, absence: true
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class Post < ApplicationRecord

        belongs_to :user
        validates :user, absence: true
      end
  ]]></script></section><section id="acceptance" class="slide"><h2>Acceptance</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddTermsOfServiceToUsers terms_of_service:boolean
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :terms_of_service, acceptance: true  # get accept: 1
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :terms_of_service, acceptance: { accept: 'yes' }
    end
  ]]></script><p>Do not this validation on the both sides of the association it causes endless cycle.</p>

</section><section id="confirmation" class="slide"><h2>Confirmation</h2>
<script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :email, :first_name, presence: true
      validates :email, confirmation: true
    end
  ]]></script></section><section id="inclusion" class="slide"><h2>Inclusion</h2>
<script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Tag < ApplicationRecord
      ...
      validates :name, inclusion: { in: %w(reading cooking programming), message: "%{value} is not a valid value" }
    end
  ]]></script></section><section id="exclusion" class="slide"><h2>Exclusion</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :first_name, exclusion: { in:  %w(Admin BadDog),  message:  "First name %{value} is reserved." }
    end
  ]]></script></section><section id="format" class="slide"><h2>Format</h2>
<script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :email, :first_name, presence: true
      validates :email, confirmation: true
      validates :email, format: { with: /^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$/, message: "Only emails allowed" }
      validates :email, format: { without: /test.com$/, message: "Test emails are not allowed" } #default message "is invalid"
    end
  ]]></script></section><section id="length" class="slide"><h2>Length</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddCardNumberToUsers card_number:string
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :first_name, length: {
        minimum: 2,
        maximum: 500,
        wrong_length: "Invalid length",
        too_long: "%{count} characters is the maximum allowed"
        too_short: "must have at least %{count} characters"
      }
      validates :password, length: { in: 6..20 }
      validates :card_number, length:  { is: 14 }
    end
  ]]></script><ul><li><code>:minimum</code> – The attribute cannot have less than the specified length.</li>
    <li><code>:maximum</code> – The attribute cannot have more than the specified length.</li>
    <li><code>:in</code> (or <code>:within</code>) – The attribute length must be included in a given interval. The value for this option must be a range.</li>
    <li><code>:is</code> – The attribute length must be equal to the given value.</li>
  </ul></section><section id="numericality" class="slide"><h2>Numericality</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class PostInfo < ApplicationRecord
      ...
      validates :views, numericality: true
      validates :rate, numericality: { only_integer: true, greater_than: 5 }
    end
  ]]></script><ul><li><code>:greater_than</code></li>
    <li><code>:greater_than_or_equal_to</code></li>
    <li><code>:equal_to</code></li>
    <li><code>:less_than</code></li>
    <li><code>:less_than_or_equal_to</code></li>
    <li><code>:odd</code></li>
    <li><code>:even</code></li>
  </ul><p>
    By default, numericality doesn't allow nil values. You can use <code>allow_nil: true</code> option to permit it.
  </p>
</section><section id="uniqueness" class="slide"><h2>Uniqueness</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g AddPageAddressToUsers page_address:string
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :email, uniqueness: true
      validates :first_name, uniqueness: { scope: :email,  message: "should only one user with name and email" }
      validates :page_address, uniqueness: { case_sensitive:  false }
    end

  ]]></script></section><section id="validates-associated" class="slide"><h2>Validates Assosiated</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      has_many :posts
      validates_associated :posts
    end
  ]]></script></section><section id="validates-with" class="slide"><h2>validates_with</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates_with GoodnessValidator
    end

    class GoodnessValidator < ActiveModel::Validator
      def validate(record)
        if record.first_name == "Evil"
          record.errors[:base] << "This user is evil"
        end
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates_with GoodnessValidator, fields: [:first_name, :last_name]
    end

    class GoodnessValidator < ActiveModel::Validator
      def validate(record)
        if options[:fields].any?{|field| record.send(field) == "Evil" }
          record.errors[:base] << "This user is evil"
        end
      end
    end
  ]]></script></section><section id="validate-each" class="slide"><h2>validate_each</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates_each :first_name, :last_name do |record, attr, value|
        record.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
      end
    end
  ]]></script></section><section id="general-options" class="slide"><h2>General options</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      validates :title, allow_nil: true
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates :last_name, allow_blank: true
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates :last_name, presence: { message: "is mandatory" }
      validates :age, numericality: { message: "%{attribute} for %{model} has %{value} that seems wrong" }

      # Proc
      validates :username,
        uniqueness: {
          # object = person object being validated
          # data = { model: "User", attribute: "Username", value: <username> }
          message: ->(object, data) do
            "Hey #{object.name}!, #{data[:value]} is taken already! Try again #{Time.zone.tomorrow}"
          end
        }
    end
  ]]></script><p>:allow_nil and :allow_blank are ignored by :presence</p>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      # it will be possible to update email with a duplicated value
      validates :email, uniqueness: true, on: :create

      # it will be possible to create the record with a non-numerical age
      validates :card_number, numericality: true, on: :update

      # the default (validates on both create and update)
      validates :first_name, presence: true, on: :save

      validates :email, uniqueness: true, on: :registration
      #Custom contexts need to be triggered explicitly by passing name of the context to valid?, invalid? or save.
    end
  ]]></script></section><section id="strict-validations" class="slide"><h2>Strict validations</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      attr_accessible :email, :first_name, :password

      has_many :posts
      validates :email, presence: { strict: true }
    end

    User.new.valid?  # => ActiveModel::StrictValidationFailed: "Email can't be blank"
  ]]></script></section><section id="conditional-validations" class="slide"><h2>Condional validations</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      class User < ApplicationRecord
        validates :card_number, presence: true, if: :paid_with_card?

        def paid_with_card?
          payment_type == "card"
        end
      end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      validates :last_name, presence: true, if: "first_name.nil?"
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      validates :password, confirmation: true, unless: Proc.new { |a| a.password.blank? }
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      with_options if: :is_admin? do |admin|
        admin.validates :password, length: { minimum: 10 }
        admin.validates :email, presence: true
      end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates :password, confirmation: true
                           if: ["editor?", :api_user?],
                           unless: Proc.new { |u| u.admin? }
    end
  ]]></script></section><section id="custom-validators" class="slide"><h2>Custom Validators</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class MyValidator < ActiveModel::Validator
      def validate(record)
        unless record.first_name.starts_with? 'X'
          record.errors[:first_name] << 'Need a name starting with X please!'
        end
      end
    end

    class User
      include ActiveModel::Validations
      validates_with MyValidator
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class EmailValidator < ActiveModel::EachValidator
      def validate_each(record, attribute, value)
        unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
          record.errors[attribute] << (options[:message] || "is not an email")
        end
      end
    end

    class User < ActiveRecord::Base
      validates :email, presence: true, email: true
    end
  ]]></script></section><section id="custom-methods" class="slide"><h2>Custom Methods</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      bin/rails g model Payment discount:decimal{8.2} total_value:decimal{8.2} expiration_date:date
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Payment < ActiveRecord::Base
      belongs_to :user_plan
      validate :expiration_date_cannot_be_in_the_past,
        :discount_cannot_be_greater_than_total_value

      def expiration_date_cannot_be_in_the_past
        if !expiration_date.blank? and expiration_date < Date.today
          errors.add(:expiration_date, "can't be in the past")
        end
      end

      def discount_cannot_be_greater_than_total_value
        if discount > total_value
          errors.add(:discount, "can't be greater than total value")
        end
      end
    end
  ]]></script></section><section id="validation-errors" class="slide"><h2>Validation Errors</h2>
  <h3>errors.add</h3>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      def a_method_used_for_validation_purposes
        errors.add(:first_name, "cannot contain the characters !@#%*()_-+=")
        # errors[:first_name] = "cannot contain the characters !@#%*()_-+="
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    user = User.create(:first_name => "!@#")
    user.errors[:first_name] # => ["cannot contain the characters !@#%*()_-+="]
    user.errors.full_messages  # => ["Name cannot contain the characters !@#%*()_-+="]
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      def a_method_used_for_validation_purposes
        errors[:base] << "This user is invalid because ..."
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      errors.clear
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      errors.size
  ]]></script></section><section id="topic-callbacks" class="slide"><div class="vcenter">
    <h1>Active Record Callbacks</h1>
  </div>
</section><section id="callback-registrations" class="slide"><h2>Callback registrations</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddLoginToUsers login:string
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      validates :login, :email, presence: true

      before_validation :ensure_login_has_a_value

      before_create do |user|
        user.first_name = user.login.capitalize if user.first_name.blank?
      end

      protected

      def ensure_login_has_a_value
        if login.nil?
          self.login = email unless email.blank?
        end
      end
    end
  ]]></script></section><section id="availiable-callbacks" class="slide"><h2>Availiable Callbacks</h2>
  <h3>Creating an Object</h3>
  <ol><li><code>before_validation</code></li>
    <li><code>after_validation</code></li>
    <li><code>before_save</code></li>
    <li><code>around_save</code></li>
    <li><code>before_create</code></li>
    <li><code>around_create</code></li>
    <li><code>after_create</code></li>
    <li><code>after_save</code></li>
    <li><code>after_commit/after_rollback</code></li>
  </ol><h3>Updating an Object</h3>
  <ol><li><code>before_validation</code></li>
    <li><code>after_validation</code></li>
    <li><code>before_save</code></li>
    <li><code>around_save</code></li>
    <li><code>before_update</code></li>
    <li><code>around_update</code></li>
    <li><code>after_update</code></li>
    <li><code>after_save</code></li>
    <li><code>after_commit/after_rollback</code></li>
  </ol><h3>Destroying an Object</h3>
  <ol><li><code>before_destroy</code></li>
    <li><code>around_destroy</code></li>
    <li><code>after_destroy</code></li>
    <li><code>after_commit/after_rollback</code></li>
  </ol></section><section id="after-callbacks" class="slide"><h2>After_find and after_initialize</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[

    class User < ApplicationRecord
      after_initialize do |user|
        puts "You have initialized an object!"
      end

      after_find do |user|
        puts "You have found an object!"
      end
    end

    >> User.new
    You have initialized an object!
    => #<User id: nil, first_name: nil, email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false>

    >> User.first
    You have found an object!
    You have initialized an object!
    => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>

  ]]></script><h2>After_touch</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      after_touch do |user|
        puts "You have touched an object"
      end
    end

    >> u = User.create(name: 'Martin')
    => #<User id: 1, name: "Martin", created_at: "2016-04-14 21:17:49", updated_at: "2016-04-14 21:17:49">

    >> u.touch
    You have touched an object
    => true
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      belongs_to :user, touch: true
      after_touch do
        puts 'An Post was touched'
      end
    end

    class User < ApplicationRecord
      has_many :posts
      after_touch :notify

      private
      def notify
        puts 'User was touched'
      end
    end

    >> @post = Post.last
    => #<Post id: 1, user_id: 1, created_at: "2016-04-15 17:08:32", updated_at:  "2016-04-15 17:08:32">

    # triggers @post.user.touch
    >> @post.touch
    User was touched
    An Post was touched
    => true
  ]]></script></section><section id="running-callbacks" class="slide"><h2>Running Callbacks</h2>
  <ul><li><code>create</code></li>
    <li><code>create!</code></li>
    <li><code>decrement!</code></li>
    <li><code>destroy</code></li>
    <li><code>destroy!</code></li>
    <li><code>destroy_all</code></li>
    <li><code>increment!</code></li>
    <li><code>save</code></li>
    <li><code>save!</code></li>
    <li><code>save(validate: false)</code></li>
    <li><code>toggle!</code></li>
    <li><code>update</code></li>
    <li><code>update_attribute</code></li>
    <li><code>update</code></li>
    <li><code>update!</code></li>
    <li><code>valid?</code></li>
  </ul><h2>after_find</h2>
  <ul><li><code>all</code></li>
    <li><code>first</code></li>
    <li><code>find</code></li>
    <li><code>find_by_*</code></li>
    <li><code>find_by_*!</code></li>
    <li><code>find_by_sql</code></li>
    <li><code>last</code></li>
  </ul></section><section id="skipping-callbacks" class="slide"><h2>Skipping callbacks</h2>
  <ul><li><code>decrement</code></li>
    <li><code>decrement_counter</code></li>
    <li><code>delete</code></li>
    <li><code>delete_all</code></li>
    <li><code>increment</code></li>
    <li><code>increment_counter</code></li>
    <li><code>toggle</code></li>
    <li><code>touch</code></li>
    <li><code>update_column</code></li>
    <li><code>update_columns</code></li>
    <li><code>update_all</code></li>
    <li><code>update_counters</code></li>
  </ul><p>
    The whole callback chain is wrapped in a transaction.
    If any before callback method returns exactly false or raises an exception,
    the execution chain gets halted and a ROLLBACK is issued;
    after callbacks can only accomplish that by raising an exception.
  </p>
</section><section id="relational-callbacks" class="slide"><h2>Relational Callbacks</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      ...
      has_many :posts, dependent: :destroy
    end

    class Post < ApplicationRecord
      ...
      after_destroy :log_destroy_action

      def log_destroy_action
        puts 'Post destroyed'
      end
    end
]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > user = User.first
      => #<User id: 1>
    > user.posts.create!
      => #<Post id: 1, user_id: 1>
    > user.destroy
      # Post destroyed
      => #<User id: 1>
  ]]></script></section><section id="conditional-callbacks" class="slide"><h2>Conditional Callbacks</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    before_save :normalize_card_number, if: :paid_with_card?
    before_save :normalize_card_number, if: "paid_with_card?"
    before_save :normalize_card_number, if: Proc.new { |order| order.paid_with_card? }
    after_create :send_email_to_user,   if: :user_wants_emails?, unless: Proc.new { |comment| comment.post.ignore_comments? }
]]></script></section><section id="callback-classes" class="slide"><h2>Callback Classes</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class PictureFileCallbacks
      def after_destroy(picture_file)
        if File.exists?(picture_file.filepath)
          File.delete(picture_file.filepath)
        end
      end
    end
]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class PictureFile < ApplicationRecord
      after_destroy PictureFileCallbacks.new
    end
]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     class PictureFileCallbacks
      def self.after_destroy(picture_file)
        if File.exists?(picture_file.filepath)
          File.delete(picture_file.filepath)
        end
      end
    end
]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     class PictureFile < ApplicationRecord
      after_destroy PictureFileCallbacks
    end
]]></script></section><section id="transaction-callbacks" class="slide"><h2>Transaction Callbacks</h2>

  <ul><li><code>after_commit</code></li>
    <li><code>after_rollback</code></li>
  </ul><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      PictureFile.transaction do
        picture_file_1.destroy
        picture_file_2.save!
      end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
   class PictureFile < ApplicationRecord
     after_commit :delete_picture_file_from_disk, on: [:destroy]

     def delete_picture_file_from_disk
       if File.exist?(filepath)
         File.delete(filepath)
       end
     end
    end
  ]]></script><ul><li><code>after_create_commit</code></li>
    <li><code>after_update_commit</code></li>
    <li><code>after_destroy_commit</code></li>
  </ul></section><section id="topic-query-interface" class="slide"><div class="vcenter">
    <h1>Query Interface</h1>
  </div>
</section><section id="retrieving-methods" class="slide"><h2>Retrieving Objects from the Database</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    find
    create_with
    distinct
    eager_load
    extending
    from
    group
    having
    includes
    joins
    left_outer_joins
    limit
    lock
    none
    offset
    order
    preload
    readonly
    references
    reorder
    reverse_order
    select
    where
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      ActiveRecord::Relation
  ]]></script></section><section id="retrieving-single-object" class="slide"><h2>Retrieving a Single Object</h2>
  Using a Primary Key
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find(1)
      User Load (0.4ms)  SELECT "users".* FROM "users" WHERE "users"."id" = ? LIMIT 1  [["id", 1]]
     => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>
  ]]></script>
  take
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.take
      User Load (0.5ms)  SELECT "users".* FROM "users" LIMIT 1
     => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>
  ]]></script>

  first
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.first
      User Load (0.6ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 1
     => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>
  ]]></script>

  last
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.last
      User Load (0.5ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" DESC LIMIT 1
     => #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>
  ]]></script>
  take, first, last, find_by returns nil if no matching record is found and no exception will be raised.
  take!, first!, last!, find_by! raise ActiveRecord::RecordNotFound if no matching record is found.

  find_by
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_by first_name: "Anna"
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."first_name" = 'Anna' LIMIT 1
     => #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_by first_name: "Anna", email: "some@ua.fm"
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."first_name" = 'Anna' AND "users"."email" = 'some@ua.fm' LIMIT 1
     => nil
  ]]></script></section><section id="retrieving-multiple-objects" class="slide"><h2>Retrieving Multiple Objects</h2>
  Using Multiple Primary Keys
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find([1, 2]) # User.find(1, 2)
      User Load (0.7ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (1, 2)
     => [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script>
  take
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.take(2)
      User Load (0.5ms)  SELECT "users".* FROM "users" LIMIT 2
     => [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script>

  first
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
   > User.first(2)
      User Load (0.5ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 2
     => [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script>

  last
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.last(2)
      User Load (0.6ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" DESC LIMIT 2
     => [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script></section><section id="retrieving-multiple-in-batches" class="slide"><h2>Retrieving Multiple Objects in Batches</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.all.each do |user|
        puts user.first_name
      end
      User Load (0.5ms)  SELECT "users".* FROM "users"
      Anna
      Vanka
       => [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script>

  find_each
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_each do |user|
        puts user.first_name
      end
      User Load (0.7ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 1000
      Anna
      Vanka
       => nil
  ]]></script>

  :batch_size

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_each(batch_size: 1) do |user|
        puts user.first_name
      end
        User Load (0.3ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 1
      Anna
        User Load (0.2ms)  SELECT "users".* FROM "users" WHERE ("users"."id" > 1) ORDER BY "users"."id" ASC LIMIT 1
      Vanka
        User Load (0.1ms)  SELECT "users".* FROM "users" WHERE ("users"."id" > 2) ORDER BY "users"."id" ASC LIMIT 1
       => nil
  ]]></script>

  :start

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_each(start: 2, batch_size: 1) do |user|
        puts user.first_name
      end
        User Load (0.7ms)  SELECT "users".* FROM "users" WHERE ("users"."id" >= 2) ORDER BY "users"."id" ASC LIMIT 1
        Vanka
          User Load (0.6ms)  SELECT "users".* FROM "users" WHERE ("users"."id" > 2) ORDER BY "users"."id" ASC LIMIT 1
         => nil
  ]]></script>

  find_in_batches

    <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.find_in_batches(include: :tags) do |posts|
        puts posts.map(&:tags)
      end
      Post Load (0.5ms)  SELECT "posts".* FROM "posts" ORDER BY "posts"."id" ASC LIMIT 1000
      SQL (0.5ms)  SELECT "tags".*, "t0"."post_id" AS ar_association_key_name FROM "tags" INNER JOIN "posts_tags" "t0" ON "tags"."id" = "t0"."tag_id" WHERE "t0"."post_id" IN (1, 2)
      #<Tag:0x00000004920618>
  ]]></script></section><section id="conditions" class="slide"><h2>Conditions</h2>
  String conditions
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where("first_name = 'Anna'")
    User Load (0.4ms)  SELECT "users".* FROM "users" WHERE (first_name = 'Anna')
     => #<ActiveRecord::Relation [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>]>

  ]]></script>

  Array conditions

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    User.where("email = ?", params[:email])
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    User.where("last_name = ? AND receive_news = ?", params[:last_name], true)
  ]]></script>

  Placeholder conditions
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Payment.where("created_at >= :start_date", { start_date: 10.days.ago })
    Payment Load (0.1ms)  SELECT "payments".* FROM "payments" WHERE (created_at >= '2013-06-13 18:56:01.086812')
      => #<ActiveRecord::Relation []>
  ]]></script>

  Hash conditions
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    User.where(first_name: 'Anna')
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    User.where('first_name' => 'Anna')
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    > Post.where(user: User.first)
    SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = 1
      => #<ActiveRecord::Relation []>
  ]]></script>

  Range conditions
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE ("users"."created_at" BETWEEN '2013-06-21 21:00:00.000000' AND '2013-06-22 21:00:00.000000')
        => #<ActiveRecord::Relation []>
  ]]></script>

  Subset conditions
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > Tag.where(name: ['cooking', 'programming'])
      SELECT "tags".* FROM "tags" WHERE "tags"."name" IN ('cooking', 'programming')
        => #<ActiveRecord::Relation []>
  ]]></script>

  NOT conditions
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > Post.where.not(user: User.first)
      User Load (0.2ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT 1
      Post Load (0.2ms)  SELECT "posts".* FROM "posts" WHERE ("posts"."user_id" != 1)
       => #<ActiveRecord::Relation []>
  ]]></script></section><section id="ordering" class="slide"><h2>Ordering</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.order("created_at")
        SELECT "users".* FROM "users" ORDER BY created_at
     => #<ActiveRecord::Relation [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script>
  ASC, DESC

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      User.order("created_at ASC")
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      User.order("created_at DESC")
  ]]></script>

  ordering by multiple fields

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      User.order("id ASC,created_at DESC")
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      User.order("id ASC").order("created_at DESC")
  ]]></script></section><section id="selecting" class="slide"><h2>Selecting</h2>
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    User.select("first_name, email")
    User Load (0.4ms)  SELECT first_name, email FROM "users"
     => #<ActiveRecord::Relation [#<User id: nil, first_name: "Anna", email: "happy_ann@gmail.com">, #<User id: nil, first_name: "Van'ka", email: "vanka@yandex.ru">]>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      User.select("status")
      User Load (0.6ms)  SELECT status FROM "users"
      SQLite3::SQLException: no such column: status: SELECT status FROM "users"
      ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: status: SELECT status FROM "users"
  ]]></script>

  distinct

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.select(:first_name).distinct
      User Load (0.5ms)  SELECT DISTINCT first_name FROM "users"
       => #<ActiveRecord::Relation [#<User id: nil, first_name: "Anna">, #<User id: nil, first_name: "Van'ka">]>
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    query = User.select(:name).distinct
    query.distinct(false)
  ]]></script></section><section id="limit-and-offset" class="slide"><h2>Limit and Offset</h2>
   limit
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.limit(5)
       User Load (0.6ms)  SELECT "users".* FROM "users" LIMIT 5
       => #<ActiveRecord::Relation [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script>

  offset
    <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.limit(5).offset(1)
      User Load (0.5ms)  SELECT "users".* FROM "users" LIMIT 5 OFFSET 1
      => #<ActiveRecord::Relation [#<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script></section><section id="group" class="slide"><h2>Group</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > p = PostInfo.select("id, sum(views) AS sum_views").group("post_id")
      PostInfo Load (0.5ms)  SELECT id, sum(views) AS sum_views FROM "post_infos" GROUP BY post_id
     => #<ActiveRecord::Relation [#<PostInfo id: 1>, #<PostInfo id: 2>]>
    > p.each{ |p| puts p.sum_views }
     9
     2
     => [#<PostInfo id: 1>, #<PostInfo id: 2>]
  ]]></script></section><section id="having" class="slide"><h2>Having</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > p = PostInfo.select("id, sum(views) AS sum_views").group("post_id").having("sum(views) > 5")
        PostInfo Load (0.5ms)  SELECT id, sum(views) AS sum_views FROM "post_infos" GROUP BY post_id HAVING sum(views) > 5
      => #<ActiveRecord::Relation [#<PostInfo id: 1>]>
      > p.each{ |p| puts p.sum_views }
      9
      => [#<PostInfo id: 1>]
  ]]></script></section><section id="overriding-conditions" class="slide"><h2>Overriding Conditions</h2>

except
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.where('id > 2').limit(2).except(:limit)
      Post Load (0.5ms)  SELECT "posts".* FROM "posts" WHERE (id > 2)
     => #<ActiveRecord::Relation [#<Post id: 3, text: "New post", user_id: 1, created_at: "2013-06-02 19:06:35", updated_at: "2013-06-02 19:06:35", title: nil, published: nil>, #<Post id: 4, text: "Some text", user_id: 2, created_at: "2013-06-23 20:18:11", updated_at: "2013-06-23 20:18:11", title: "First step", published: nil>]>
  ]]></script>

  unscope
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      Post.order('id DESC').limit(20).unscope(:order) # == Post.limit(20)
      Post.order('id DESC').limit(20).unscope(:order, :limit) # == Post.all
  ]]></script>

  only

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.where('id > 2').limit(2).order('id desc')
     Post Load (0.5ms)  SELECT "posts".* FROM "posts" WHERE (id > 2) ORDER BY id desc LIMIT 2
      => #<ActiveRecord::Relation [#<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06-23 20:18:23", title: "First step", published: nil>, #<Post id: 4, text: "Some text", user_id: 2, created_at: "2013-06-23 20:18:11", updated_at: "2013-06-23 20:18:11", title: "First step", published: nil>]>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.where('id > 2').limit(2).order('id desc').only(:order, :where)
      Post Load (0.5ms)  SELECT "posts".* FROM "posts" WHERE (id > 2) ORDER BY id desc
      => #<ActiveRecord::Relation [#<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06-23 20:18:23", title: "First step", published: nil>, #<Post id: 4, text: "Some text", user_id: 2, created_at: "2013-06-23 20:18:11", updated_at: "2013-06-23 20:18:11", title: "First step", published: nil>, #<Post id: 3, text: "New post", user_id: 1, created_at: "2013-06-02 19:06:35", updated_at: "2013-06-02 19:06:35", title: nil, published: nil>]>
  ]]></script>

  reorder
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User <  ApplicationRecord
      ...
      has_many :posts, -> { order('created_at DESC') }
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find(2).posts.reorder('title')
      User Load (0.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = ? LIMIT 1  [["id", 2]]
      Post Load (0.6ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ? ORDER BY title  [["user_id", 2]]
     => #<ActiveRecord::Relation [#<Post id: 4, text: "Some text", user_id: 2, created_at: "2013-06-23 20:18:11", updated_at: "2013-06-23 20:18:11", title: "First step", published: nil>, #<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06">]
  ]]></script>
  reverse_order

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.order(:created_at)
    User Load (0.6ms)  SELECT "users".* FROM "users" ORDER BY "users".created_at ASC
      => #<ActiveRecord::Relation [#<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.order(:created_at).reverse_order
    User Load (0.6ms)  SELECT "users".* FROM "users" ORDER BY "users".created_at DESC
      => #<ActiveRecord::Relation [#<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>, #<User id: 1, first_name: "Anna", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-02 17:23:02", last_name: nil, receive_news: false>]>
  ]]></script>

  rewhere

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where(admin: true).rewhere(admin: false)
      SELECT * FROM users WHERE `admin` = 0
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where(admin: true).where(admin: false)
      SELECT * FROM users WHERE `admin` = 1 AND `admin` = 0
  ]]></script></section><section id="null-relation" class="slide"><h2>Null Relation</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    Post.none # returns an empty Relation and fires no queries.
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    # The visible_posts method below is expected to return a Relation.
      @posts = current_user.visible_posts.where(title: params[:title])

      def visible_posts
        case role
        when 'Reviewer'
          Post.published
        when 'Bad User'
          Post.none
        end
      end
  ]]></script></section><section id="readonly" class="slide"><h2>Readonly</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    user  = User.readonly.first
    user.first_name = "Anny"
    user.save

    ActiveRecord::ReadOnlyRecord: ActiveRecord::ReadOnlyRecord
  ]]></script></section><section id="optimistic-locking" class="slide"><h2>Locking Records for Update</h2>
  <h3>Optimistic locking</h3>
  <p>Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. It does this by checking whether another process has made changes to a record since it was opened, an ActiveRecord::StaleObjectError exception is thrown if that has occurred and the update is ignored.</p>

  <p><code>lock_version</code> field should present. Each update to the record increments the lock_version column and the locking facilities ensure that records instantiated twice will let the last one saved raise a StaleObjectError if the first was also updated.</p>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    u1 = User.find(1)
    u2 = User.find(1)

    u1.first_name = "Michael"
    u1.save

    u2.first_name = "should fail"
    u2.save # Raises an ActiveRecord::StaleObjectError
  ]]></script></section><section id="pessimistic-locking" class="slide"><h2>Locking Records for Update</h2>
  <h3>Pessimistic locking</h3>

  <p>It provides support for row-level locking using SELECT … FOR UPDATE and other lock types.</p>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    User.transaction do
      user = User.find(1, lock: true)
      user.first_name = 'Marta'
      user.save
    end
  ]]></script></section><section id="joining-tables" class="slide"><h2>Joining Tables</h2>

  Using a String SQL Fragmen

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > users = User.joins('LEFT OUTER JOIN posts ON posts.user_id = users.id')
        User Load (0.3ms)  SELECT "users".* FROM "users" LEFT OUTER JOIN posts ON posts.user_id = users.id
     => #<ActiveRecord::Relation [#<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>

    > users.length
      User Load (0.7ms)  SELECT "users".* FROM "users" LEFT OUTER JOIN posts ON posts.user_id = users.id
     => 5

    > Post.all.length
      Post Load (0.5ms)  SELECT "posts".* FROM "posts"
     => 5
  ]]></script>

  left_outer_joins

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.left_outer_joins(:posts).distinct
      User Load (1.4ms)  SELECT DISTINCT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
    => #<ActiveRecord::Relation [#<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script>

  Joining a Single Association

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.joins(:posts)
    User Load (0.5ms)  SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  ]]></script>

  Joining Multiple Associations

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.joins(:tags, :blog)
      Post Load (0.6ms)  SELECT "posts".* FROM "posts" INNER JOIN "posts_tags" ON "posts_tags"."post_id" = "posts"."id" INNER JOIN "tags" ON "tags"."id" = "posts_tags"."tag_id" INNER JOIN "blogs" ON "blogs"."id" = "posts"."blog_id"
     => #<ActiveRecord::Relation [#<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06-23 21:24:37", title: "First step", published: nil, blog_id: 1>]>
      ]]></script>

  Joining Nested Associations (Single Level)

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
     > Post.joins(blog: :users)
       Post Load (0.2ms)  SELECT "posts".* FROM "posts" INNER JOIN "blogs" ON "blogs"."id" = "posts"."blog_id" INNER JOIN "subscriptions" ON "subscriptions"."blog_id" = "blogs"."id" INNER JOIN "users" ON "users"."id" = "subscriptions"."user_id"
  ]]></script>

  Joining Nested Associations (Multiple Level)

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
     > User.joins(posts: [{blog: :subscriptions}, :tags])
       User Load (0.8ms)  SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" INNER JOIN "blogs" ON "blogs"."id" = "posts"."blog_id" INNER JOIN "subscriptions" ON "subscriptions"."blog_id" = "blogs"."id" INNER JOIN "posts_tags" ON "posts_tags"."post_id" = "posts"."id" INNER JOIN "tags" ON "tags"."id" = "posts_tags"."tag_id" WHERE "users"."state" = 'pending'
  ]]></script>

  Specifying Conditions on the Joined Tables

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.joins(:posts).where('posts.created_at' => (Time.now.midnight - 1.day)..Time.now.midnight)
      User Load (0.5ms)  SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE ("posts"."created_at" BETWEEN '2013-06-22 21:00:00.000000' AND '2013-06-23 21:00:00.000000')
     => #<ActiveRecord::Relation [#<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
  ]]></script></section><section id="eager-loading-associations" class="slide"><h2>Eager Loading Associations</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    users = User.limit(10)

    users.each do |user|
      puts user.posts.map(&:title)
    end

    User Load (0.6ms)  SELECT "users".* FROM "users" LIMIT 10
      => #<ActiveRecord::Relation [#<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
    Post Load (0.6ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ?  [["user_id", 1]]
    =>
    Post Load (0.3ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ?  [["user_id", 2]]

    => First step
       First step
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    users = User.includes(:posts).limit(10)

    users.each do |user|
      puts user.posts.map(&:title)
    end

    User Load (0.6ms)  SELECT "users".* FROM "users" LIMIT 10
    Post Load (0.3ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2)
      => #<ActiveRecord::Relation [#<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]>
      =>
      =>  First step
          First step
      => [#<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>, #<User id: 2, first_name: "Van'ka", email: "vanka@yandex.ru", password: nil, created_at: "2013-06-02 18:18:40", updated_at: "2013-06-02 18:20:00", last_name: nil, receive_news: false>]
  ]]></script>
  Array of Multiple Associations
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    >p =  Post.includes(:blog, :tags)
      Post Load (0.5ms)  SELECT "posts".* FROM "posts"
      Blog Load (0.3ms)  SELECT "blogs".* FROM "blogs" WHERE "blogs"."id" IN (1)
      SQL (0.3ms)  SELECT "tags".*, "t0"."post_id" AS ar_association_key_name FROM "tags" INNER JOIN "posts_tags" "t0" ON "tags"."id" = "t0"."tag_id" WHERE "t0"."post_id" IN (1, 2, 3, 4, 5)
       => #<ActiveRecord::Relation [#<Post id: 1, text: "I'm so happy today", user_id: 1, created_at: "2013-06-02 18:43:10", updated_at: "2013-06-02 18:43:10", title: nil, published: nil, blog_id: nil>, #<Post id: 2, text: "I'm waiting", user_id: 1, created_at: "2013-06-02 19:01:45", updated_at: "2013-06-02 19:01:45", title: nil, published: nil, blog_id: nil>, #<Post id: 3, text: "New post", user_id: 1, created_at: "2013-06-02 19:06:35", updated_at: "2013-06-02 19:06:35", title: nil, published: nil, blog_id: nil>, #<Post id: 4, text: "Some text", user_id: 2, created_at: "2013-06-23 20:18:11", updated_at: "2013-06-23 20:18:11", title: "First step", published: nil, blog_id: nil>, #<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06-23 21:24:37", title: "First step", published: nil, blog_id: 1>]>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > p.first.tags
     => #<ActiveRecord::Associations::CollectionProxy []>
  ]]></script>

  Nested Associations Hash
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.includes([:subscriptions, {:posts => [:tags]}]).find(1)
      User Load (1.9ms)  SELECT "users".* FROM "users" WHERE "users"."id" = ? LIMIT 1  [["id", 1]]
      Subscription Load (0.1ms)  SELECT "subscriptions".* FROM "subscriptions" WHERE "subscriptions"."user_id" IN (1)
      Post Load (0.2ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1)
      SQL (0.2ms)  SELECT "tags".*, "t0"."post_id" AS ar_association_key_name FROM "tags" INNER JOIN "posts_tags" "t0" ON "tags"."id" = "t0"."tag_id" WHERE "t0"."post_id" IN (1, 2, 3)
     => #<User id: 1, first_name: "Marta", email: "happy_ann@gmail.com", password: nil, created_at: "2013-06-02 17:23:02", updated_at: "2013-06-23 21:02:23", last_name: nil, receive_news: false>
  ]]></script>

  Specifying Conditions on Eager Loaded Associations

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > p = Post.includes(:tags).where("tags.name != 'nil'")
      SQL (0.7ms)  SELECT "posts"."id" AS t0_r0, "posts"."text" AS t0_r1, "posts"."user_id" AS t0_r2, "posts"."created_at" AS t0_r3, "posts"."updated_at" AS t0_r4, "posts"."title" AS t0_r5, "posts"."published" AS t0_r6, "posts"."blog_id" AS t0_r7, "tags"."id" AS t1_r0, "tags"."name" AS t1_r1, "tags"."created_at" AS t1_r2, "tags"."updated_at" AS t1_r3 FROM "posts" LEFT OUTER JOIN "posts_tags" ON "posts_tags"."post_id" = "posts"."id" LEFT OUTER JOIN "tags" ON "tags"."id" = "posts_tags"."tag_id" WHERE (tags.name != 'nil')
      => #<ActiveRecord::Relation [#<Post id: 5, text: "Some another text", user_id: 2, created_at: "2013-06-23 20:18:23", updated_at: "2013-06-23 21:24:37", title: "First step", published: nil, blog_id: 1>]>
    > p.first.tags
    => #<ActiveRecord::Associations::CollectionProxy [#<Tag id: 1, name: "good", created_at: "2013-06-23 21:25:07", updated_at: "2013-06-23 21:25:07">]>
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > p = Post.includes(:tags).where("tags.name != 'nil'").references(:tags)
    SQL (0.7ms)  SELECT "posts"."id" AS t0_r0, "posts"."text" AS t0_r1, "posts"."user_id" AS t0_r2, "posts"."created_at" AS t0_r3, "posts"."updated_at" AS t0_r4, "posts"."title" AS t0_r5, "posts"."published" AS t0_r6, "posts"."blog_id" AS t0_r7, "tags"."id" AS t1_r0, "tags"."name" AS t1_r1, "tags"."created_at" AS t1_r2, "tags"."updated_at" AS t1_r3 FROM "posts" LEFT OUTER JOIN "posts_tags" ON "posts_tags"."post_id" = "posts"."id" LEFT OUTER JOIN "tags" ON "tags"."id" = "posts_tags"."tag_id" WHERE (tags.name != 'nil')
  ]]></script></section><section id="scopes" class="slide"><h2>Scopes</h2>

  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      ...
      scope :published, -> { where(published: true) }
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      ...
      def self.published
        where(published: true)
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      scope :published,               -> { where(published: true) }
      scope :published_with_tags, -> { published.where("tags_count > 0") }
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      Post.published
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
      Tags.first.posts.published
  ]]></script>

  Passing in arguments
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class Post < ApplicationRecord
      ...
      scope :created_before, ->(time) { where("created_at < ?", time) }
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
     Post.created_before(Time.now)
  ]]></script>

  Merging of scopes

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bin/rails g migration AddStateToUser state:string
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      scope :active, -> { where state: 'active' }
      scope :inactive, -> { where state: 'inactive' }
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.active.inactive
      User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.active.where(state: 'finished')
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
  ]]></script>

If we do want the last where clause to win
<script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.active.merge(User.inactive)
      User Load (0.6ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
  ]]></script>

default_scope
- will be applied across all queries
- will be overridden by scope and where conditions
<script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
  class User < ApplicationRecord
    default_scope { where state: 'pending' }
    scope :active, -> { where state: 'active' }
    scope :inactive, -> { where state: 'inactive' }
  end
]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
  > User.all
    User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'
]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
  > User.active
    User Load (0.6ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'active'
]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
  > User.where(state: 'inactive')
    User Load (0.6ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
]]></script>

Removing All Scoping

<script type="syntaxhighlighter" class="brush: bash"><![CDATA[
  > User.unscoped.all
    SELECT "users".* FROM "users"
]]></script></section><section id="dynamic-finders" class="slide"><h2>Dynamic finders</h2>

<code>first_name -&gt; find_by_first_name or find_by_first_name! </code>
</section><section id="find-or-build" class="slide"><h2>Find or Build a New Object</h2>

  find_or_create_by

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.find_or_create_by(first_name: 'Mark')
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."first_name" = 'Mark' LIMIT 1
       (0.3ms)  begin transaction
      SQL (3.8ms)  INSERT INTO "users" ("created_at", "first_name", "state", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 24 Jun 2013 09:26:43 UTC +00:00], ["first_name", "Mark"], ["state", "pending"], ["updated_at", Mon, 24 Jun 2013 09:26:43 UTC +00:00]]
       (134.1ms)  commit transaction
     => #<User id: 3, first_name: "Mark", email: nil, password: nil, created_at: "2013-06-24 09:26:43", updated_at: "2013-06-24 09:26:43", last_name: nil, receive_news: false, state: "pending">
  
    > User.find_or_create_by(first_name: 'Mark')
      User Load (0.6ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."first_name" = 'Mark' LIMIT 1
     => #<User id: 3, first_name: "Mark", email: nil, password: nil, created_at: "2013-06-24 09:26:43", updated_at: "2013-06-24 09:26:43", last_name: nil, receive_news: false, state: "pending">
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    User.find_or_create_by(first_name: 'Andy') do |c|
      c.locked = false
    end
  ]]></script>

  find_or_initialize_by

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > clark = User.find_or_initialize_by(first_name: 'Clark')
      User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."first_name" = 'Clark' LIMIT 1
     => #<User id: nil, first_name: "Clark", email: nil, password: nil, created_at: nil, updated_at: nil, last_name: nil, receive_news: false, state: "pending">
  
    > clark.persisted?
     => false
  
    > clark.new_record?
     => true
  
    > clark.save
  ]]></script></section><section id="finding-by-sql" class="slide"><h2>Finding by SQL</h2>

  find_by_sql
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    >   User.find_by_sql("SELECT * FROM users INNER JOIN posts ON users.id = posts.user_id")
      User Load (0.7ms)  SELECT * FROM users INNER JOIN posts ON users.id = posts.user_id
     => [#<User id: 1, first_name: "Anna", email: "ann@ua.fm", password: "111111", created_at: "2013-06-24 08:54:47", updated_at: "2013-06-24 08:54:47", last_name: nil, receive_news: true, state: "active">, #<User id: 2, first_name: "Gregory", email: "greg@ua.fm", password: "111111", created_at: "2013-06-24 08:55:25", updated_at: "2013-06-24 08:55:25", last_name: "Taunsend", receive_news: false, state: "inactive">]
  ]]></script>

  select_all
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.connection.select_all("SELECT * FROM posts WHERE id = '1'")
       (0.5ms)  SELECT * FROM posts WHERE id = '1'
     => #<ActiveRecord::Result:0x0000000398efb0 @columns=["id", "text", "user_id", "created_at", "updated_at", "title", "published", "blog_id"], @rows=[[1, "Every trip begins with the first step", 1, "2013-06-24 08:54:47.619258", "2013-06-24 08:54:47.619258", "1000 miles", nil, nil]], @hash_rows=nil, @column_types={}>
  ]]></script>

  pluck
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.where(state: "active").pluck(:id)
        (0.5ms)  SELECT "users"."id" FROM "users" WHERE "users"."state" = 'active'
       => [1]
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.distinct.pluck(:first_name)
      (0.5ms)  SELECT DISTINCT "users"."first_name" FROM "users" WHERE "users"."state" = 'pending'
     => ["Mark", "Alice"]
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.pluck(:id, :first_name)
      (0.4ms)  SELECT "users"."id", "users"."first_name" FROM "users" WHERE "users"."state" = 'pending'
     => [[3, "Mark"], [4, "Alice"]]

  ]]></script>

  ids
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.ids
      (0.5ms)  SELECT id FROM "users" WHERE "users"."state" = 'pending'
      => [3, 4]

  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ActiveRecord::Base
      self.primary_key = "user_id"
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      > User.ids
      (0.2ms)  SELECT user_id FROM "users" WHERE "users"."state" = 'pending'
  ]]></script></section><section id="existence-of-objects" class="slide"><h2>Existence of Objects</h2>

  exists?

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.exists?(1)
      User Exists (0.2ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 1 LIMIT 1
     => true
    > User.exists?(3)
      User Exists (0.4ms)  SELECT 1 AS one FROM "users" WHERE "users"."id" = 3 LIMIT 1
     => false
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where(first_name: 'Ryan').exists?
      User Exists (0.4ms)  SELECT 1 AS one FROM "users" WHERE "users"."first_name" = 'Ryan' LIMIT 1
     => false
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.exists?
       User Exists (0.5ms)  SELECT 1 AS one FROM "users" LIMIT 1
     => true
  ]]></script>

  any? and many?
  via a model
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.any?
      (0.1ms)  SELECT COUNT(*) FROM "posts"
     => true
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > Post.many?
      (0.4ms)  SELECT COUNT(*) FROM "posts"
     => true
  ]]></script>
  via a relation
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    Post.where(published: true).any?
    Post.where(published: true).many?
  ]]></script>
  via an association
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    Post.first.tags.any?
    Post.first.tags.many?
  ]]></script></section><section id="calculations" class="slide"><h2>Calculations</h2>
  count
  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.count
      (0.4ms)  SELECT COUNT(*) FROM "users"
     => 2
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where(:first_name => 'Ryan').count
      (0.4ms)  SELECT COUNT(*) FROM "users" WHERE "users"."first_name" = 'Ryan'
     => 2
  ]]></script>

  average

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > PostInfo.average(:views)
     (0.5ms)  SELECT AVG("post_infos"."views") AS avg_id FROM "post_infos"
     => #<BigDecimal:537e948,'0.55E1',18(45)>
  ]]></script>

  minimum

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > PostInfo.minimum(:views)
      (0.4ms)  SELECT MIN("post_infos"."views") AS min_id FROM "post_infos"
     => 2
  ]]></script>

  maximum

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > PostInfo.maximum(:views)
      (0.5ms)  SELECT MAX("post_infos"."views") AS max_id FROM "post_infos"
     => 9
  ]]></script>

  sum

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > PostInfo.sum(:views)
      (0.4ms)  SELECT SUM("post_infos"."views") AS sum_id FROM "post_infos"
     => 11
  ]]></script></section><section id="running-explain" class="slide"><h2>Running EXPLAIN</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    > User.where(id: 1).joins(:posts).explain
    User Load (6.0ms)  SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE "users"."id" = ?  [["id", 1]]
  ]]></script>

  sqlite3

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    => EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE "users"."id" = ? [["id", nil]]
    0|0|0|SEARCH TABLE users USING INTEGER PRIMARY KEY (rowid=?)
    0|1|1|SCAN TABLE posts
  ]]></script>

  MySQL and MariaDB

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `posts` ON `posts`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
    +----+-------------+----------+-------+---------------+
    | id | select_type | table    | type  | possible_keys |
    +----+-------------+----------+-------+---------------+
    |  1 | SIMPLE      | users    | const | PRIMARY       |
    |  1 | SIMPLE      | posts    | ALL   | NULL          |
    +----+-------------+----------+-------+---------------+
    +---------+---------+-------+------+-------------+
    | key     | key_len | ref   | rows | Extra       |
    +---------+---------+-------+------+-------------+
    | PRIMARY | 4       | const |    1 |             |
    | NULL    | NULL    | NULL  |    1 | Using where |
    +---------+---------+-------+------+-------------+

    2 rows in set (0.00 sec)
  ]]></script>

  PostgreSQL

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
      EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE "users"."id" = 1
                                      QUERY PLAN
    ------------------------------------------------------------------------------
     Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
       Join Filter: (posts.user_id = users.id)
       ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
             Index Cond: (id = 1)
       ->  Seq Scan on posts  (cost=0.00..28.88 rows=8 width=4)
             Filter: (posts.user_id = 1)
    (6 rows)
  ]]></script></section><section id="topic-testing-models" class="slide"><div class="vcenter">
    <h1>Testing Models</h1>
    <div class="about">
      <p>A model spec should include tests for the following:</p>
      <ul><li>Validations</li>
        <li>Associations</li>
        <li>Callbacks</li>
        <li>Class and instance methods</li>
      </ul></div>
  </div>
</section><section id="tests-configuration" class="slide"><h2>Tests configuration</h2>
  Gemfile
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    group :development, :test do
      gem 'rspec-rails'
      gem 'factory_girl_rails'
    end

    group :test do
      gem 'ffaker'
      gem 'database_cleaner'
    end
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    bundle
  ]]></script><script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    rails g rspec:install
      create  .rspec
      create  spec
      create  spec/spec_helper.rb
  ]]></script>

  config/application.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    config.generators do |g|
      g.test_framework :rspec
      g.fixture_replacement :factory_girl, dir: 'spec/factories'
    end
  ]]></script></section><section id="testing-basic-structure" class="slide"><h2>Basic structure</h2>

  <script type="syntaxhighlighter" class="brush: bash"><![CDATA[
    rails g model User email:text name:text admin:boolena
      invoke  active_record
      create    db/migrate/20160410131731_create_users.rb
      create    app/models/user.rb
      invoke    rspec
      create      spec/models/user_spec.rb
      invoke      factory_girl
      create        spec/factories/users.rb
  ]]></script>

  app/models/user.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class User < ApplicationRecord
      validates :email, :first_name, presence: true
      validates :email, uniqueness: true

      has_many :posts

      scope :admins, -> { where(admin: true) }

      after_update :email_changed, if: :email_changed?

      private

      def email_changed
        UserMailer.email_changed(self).deliver
      end
    end
  ]]></script>

  app/mailers/user_mailer.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    class UserMailer < ApplicationMailer
    
      def email_changed(user)
        # Sending email
      end
    end
  ]]></script>

  spec/models/user_spec.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    require 'spec_helper'

    describe User do
      it "is invalid without an email"
      it "has unique email"
      it "is invalid without a name"

      it "has many posts"

      context ".admins" do
        it "returns list of admins"
        it "doesn't return regular users"
      end

      context "change email" do
        it "sends email changed notification"
        it "doesn't send email changed notification" do
      end
    end
  ]]></script></section><section id="database-cleaner" class="slide"><h2>Database Cleaner</h2>
  <p><a href="https://github.com/bmabey/database_cleaner" target="_blank">DatabaseCleaner</a> is a set of strategies for cleaning your database in Ruby. The original use case was to ensure a clean state during tests. Each strategy is a small amount of code but is code that is usually needed in any ruby app that is testing with a database.</p>
  spec/spec_helper.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    # This part turns off the default RSpec database cleansing strategy.
    config.use_transactional_fixtures = false

    config.before(:suite) do
      # This says that before the entire test suite runs, clear the test database out completely.
      # This gets rid of any garbage left over from interrupted or poorly-written tests - a common source of surprising test behavior.
      DatabaseCleaner.clean_with(:truncation)

      # This part sets the default database cleaning strategy to be transactions. 
      # Transactions are very fast, and for all the tests where they do work - that is, any test where the entire test runs in the RSpec process - they are preferable.
      DatabaseCleaner.strategy = :transaction
    end

    # These lines hook up database_cleaner around the beginning and end of each test, 
    # telling it to execute whatever cleanup strategy we selected beforehand.
    config.before(:each) do
      DatabaseCleaner.start
    end

    config.after(:each) do
      DatabaseCleaner.clean
    end
  ]]></script></section><section id="factory-girl" class="slide"><h2>FactoryGirl</h2>
  <p><a href="https://github.com/thoughtbot/factory_girl" target="_blank">FactoryGirl</a> is a library for setting up Ruby objects as test data.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    FactoryGirl.define do
      sequence :email do |n|
        "email#{n}@factory.com"
      end

      factory :user do
        email { FactoryGirl.generate(:email) } 
        name "John Doe"
        admin false

        factory :admin do
          admin true
        end

        factory :author do
          ignore do
            posts_count 5
          end

          after(:create) do |user, evaluator|
            create_list(:post, evaluator.posts_count, user: user)
          end
        end
      end

      factory :post do
        title "Post title"
        user
      end
    end
  ]]></script><script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    # Saved instance
    user = FactoryGirl.create(:user)

    # Unsaved instance
    user = FactoryGirl.build(:user)

    # Attribute hash (ignores associations)
    user_attributes = FactoryGirl.attributes_for(:user)

    # Stubbed object
    user_stub = FactoryGirl.build_stubbed(:user)

    # Override attributes
    user = FactoryGirl.create(:user, name: "Jack Daniel")

    # Passing a block to any of the methods above will yield the return object
    user = FactoryGirl.create(:user) do |user|
      user.posts.create(FactoryGirl.attributes_for(:post))
    end
  ]]></script></section><section id="faker" class="slide"><h2>FFaker (Faker refactored)</h2>
  <p><a href="https://github.com/ffaker/ffaker" target="_blank">Faker</a> is used to easily generate fake data: names, addresses, phone numbers, etc.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    FactoryGirl.define do
      factory :user do
        email { FFaker::Internet.email }
        name { FFaker::Name.name }
        admin false

        factory :admin do
          admin true
        end

        factory :author do
          ignore do
            posts_count 5
          end

          after(:create) do |user, evaluator|
            create_list(:post, evaluator.posts_count, user: user)
          end
        end
      end

      factory :post do
        title { FFaker::Lorem.sentence }
        user
      end
    end
  ]]></script></section><section id="testing-validations" class="slide"><h2>Testing validations</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    describe User do
      let(:user) { FactoryGirl.create :user }

      it "is invalid without an email" do
        expect(FactoryGirl.build :user, email: nil).not_to be_valid
      end

      it "does not allow duplicate emails" do
        expect(FactoryGirl.build :user, email: user.email).not_to be_valid
      end

      it "is invalid without a name" do
        expect(FactoryGirl.build :user, name: nil).not_to be_valid
      end
    end
  ]]></script></section><section id="testing-associations" class="slide"><h2>Testing associations</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    describe User do
      let(:user) { FactoryGirl.create :user }

      it "has many posts" do
        expect(user).to respond_to :posts
      end
    end
  ]]></script></section><section id="testing-scopes" class="slide"><h2>Testing scopes</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    describe User do
      context ".admins" do
        before do
          @users = FactoryGirl.create_list(:user, 3)
          @admins = FactoryGirl.create_list(:admin, 3)
        end
     
        it "returns list of admins" do
          expect(User.admins).to match_array(@admins)
        end
     
        it "doesn't return regular users" do
          expect(User.admins).not_to match_array(@users)
        end
      end
    end
  ]]></script></section><section id="testing-callbacks" class="slide"><h2>Testing callbacks</h2>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    describe User do
      let(:user) { FactoryGirl.create :user }

      context "change email" do
        it "sends email changed notification" do
          user.email = FFaker::Internet.email
          expect(UserMailer).to receive(:email_changed).with(user).and_return(double("meil", deliver: true))
          user.save
        end

        it "doesn't send email changed notification" do
          user.name = "Santa Claus"
          expect(UserMailer).not_to receive(:email_changed)
          user.save
        end
      end
    end
  ]]></script></section><section id="shoulda-matchers" class="slide"><h2>Shoulda matchers</h2>
  <p><a href="https://github.com/thoughtbot/shoulda-matchers" target="_blank">Shoulda-matchers</a> provides Test::Unit and RSpec-compatible one-liners that test common Rails functionality.</p>
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    group :test do
      gem 'shoulda-matchers'
    end
  ]]></script>

  spec/models/user_spec.rb
  <script type="syntaxhighlighter" class="brush: ruby"><![CDATA[
    require 'spec_helper'

    describe User do 
      it { expect(user).to validate_presence_of(:email) }
      it { expect(user).to validate_uniqueness_of(:email) }
      it { expect(user).to validate_presence_of(:name) }
      it { expect(user).to have_many(:posts) }
    end
  ]]></script></section><section id="homework" class="slide"><h2>Homework. Amazon.</h2>
  <p>Business logic structure:</p>
  <h3>Book</h3>
  <ul><li>Should contain title, descirption, price and how many books in stock</li>
    <li>Title, price, books in stock fields should be required</li>
    <li>Should belong to author and category</li>
    <li>Should have many ratings from costomers</li>
  </ul><h3>Category</h3>
  <ul><li>Has a title</li>
    <li>Title should be required and unique</li>
    <li>Should have many books</li>
  </ul><h3>Author</h3>
  <ul><li>Should contain firstname, lastname, biography</li>
    <li>Firstname, lastname fields should be required</li>
    <li>Should have many books</li>
  </ul><h3>Rating</h3>
  <ul><li>Should contain text review and rating number from one to ten</li>
    <li>Should belong to customer and book</li>
  </ul><h3>Customer</h3>
  <ul><li>Should contain email, password, firstname, lastname</li>
    <li>Email, password, firstname, lastname fields should be required</li>
    <li>Email should be unique</li>
    <li>Should have many orders, ratings</li>
    <li>A customer should be able to create a new order</li>
    <li>A customer should be able to return a current order in progress</li>
  </ul><p>Order</p>
  <ul><li>Should contain total price, completed date and state (in progress/complited/shipped)</li>
    <li>Total price, completed date and state fields should be required</li>
    <li>By default an order should have 'in progress' state</li>
    <li>Should belong to customer and credit card</li>
    <li>Should have many order items</li>
    <li>Should have one billing address and one shipping address</li>
    <li>An order should be able to add a book to the order</li>
    <li>An order should be able to return a total price of the order</li>
  </ul><p>OrderItem</p>
  <ul><li>Should contain price and quantity</li>
    <li>Price and quantity fields should be required</li>
    <li>Should belong to book and order</li>
  </ul><p>Address</p>
  <ul><li>Should contain address, zipcode, city, phone, country</li>
    <li>All fields should be required</li>
  </ul><p>Country</p>
  <ul><li>Should contain a name</li>
    <li>Name should be required and unique</li>
  </ul><p>CreditCard</p>
  <ul><li>Should contain number, CVV, expiration month, expiration year, firstname, lastname</li>
    <li>All fields should be required</li>
    <li>Should belong to customer and have many orders</li>
  </ul><p>Necessary to create a DB structure, models, associations and validations to models, autotests and factories for autotests.</p>
</section><!-- End slides. --><!-- deck.navigation snippet --><a href="#" class="deck-prev-link" title="Previous">←</a>
<a href="#" class="deck-next-link" title="Next">→</a>

<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

</body>
</html>
