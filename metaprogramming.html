<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>Metaprogramming in Ruby</title>

	<!-- Required stylesheet -->
	<link rel="stylesheet" href="support/core/deck.core.css">

	<!-- Extension CSS files go here. Remove or add as needed. -->
	<link rel="stylesheet" href="support/extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="support/extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="support/extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="support/extensions/status/deck.status.css">
	<link rel="stylesheet" href="support/extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="support/extensions/scale/deck.scale.css">

	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="support/themes/style/mnml.css">
	<link rel="stylesheet" href="support/themes/style/custom.css">

	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="support/themes/transition/vertical-slide.css">

	<!-- Syntax highlighter -->
	<link rel="stylesheet" href="support/extensions/syntax-highlighter/shCore.css">
	<link rel="stylesheet" href="support/extensions/syntax-highlighter/shThemeDefault.css">
	<link rel="stylesheet" href="support/extensions/syntax-highlighter/shThemeRDark.css">

	<!-- Required Modernizr file -->
	<script src="support/javascripts/modernizr.custom.js"></script>
</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->

<section class="slide" id="title">
	<h2>Metaprogramming in Ruby</h2>
	<img src="support/themes/style/images/mtp.png" alt="Metaprogramming Ruby">
</section>

<section class="slide" id="open-classes">
	<h2>Open Classes</h2>
	<div>
		In Ruby, classes are never closed: you can always add methods to an existing class. This applies to the classes you write as well as the standard, built-in classes. All you have to do is open up a class definition for an existing class, and the new contents you specify will be added to whatever's there.
	</div>
    <div class="column left">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
		class D
		    def x
		        'X'
		    end
		end

		class D
		    def y
		        'Y'
		    end
		end

		d = D.new
		d.x 	# => 'X'
		d.y 	# => 'Y']]>
	</script>
  </div>
    <div class="column right">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
		3.times do
          class C
            puts "hello"
          end
        end]]>
	  </script>

	  <script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
		# => Hello
		# => Hello
		# => Hello]]>
	  </script>
  </div>
</section>

<section class="slide" id="monkey-patch">
	<h2>Monkey See, Monkey Patch</h2>
  <div>
  In Ruby, the term <i>monkey patch</i> means any dynamic modification to a class.
  </div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
# evil example
class FixNum
    def +(adder)
        self - adder
    end
end

## that's correct, I just turned addition into subtraction
	</script>
  </div>
	<div>
	Monkey patching is a practice which involves substituting the pillars of an house: if you're not very careful in what you substitute, the whole building will collapse over your remains. Moreover, you may take down some underground stations full of people as well as a side-effect.
	</div>
</section>

<section class="slide" id="classes">
	<h2>Classes</h2>
	<div>
		Classes themselves are nothing but objects.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
"hello".class            # => String
String.class             # => Class

String.superclass        # => Object
Object.superclass        # => BasicObject
BasicObject.superclass   # => nil

Class.superclass         # => Module
Module.superclass        # => Object]]>
	</script>
  </div>
</section>


<section class="slide" id="constants">
	<h2>Constants</h2>
	<div>
		Constants’ paths use a double colon as a separator. If you’re sitting deep inside the tree of constants, you can provide the absolute path to an outer constant by using a leading double colon as root.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module M
  class C
    X = 'a constant'
  end
  C::X    # => 'a constant'
end

M::C::X   # => 'a constant'

module M
  Y = 'another constant'
  class C
    # absolute path
    ::M::Y   # => 'another constant'
  end
end
]]>
	</script>
  </div>
</section>

<section class="slide" id="constants2">
	<h2>Constants</h2>
	<div>
        The Module class also provides an instance method and a class method that are both called `constants`:   Module#constants( ) returns all constants in the current scope, Module.constants( ) returns all the top-level constants in the current program, including class names.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[

M.constants          # => [:C, :Y]
Module::constants    # => [:Object, :Module, :Class, :BasicObject, :Kernel, :NilClass, :NIL ...

module M
  class C
    module M2
      puts Module.nesting    # => [M::C::M2, M::C, M]
    end
  end
end
]]>
	</script>
  </div>
</section>

<section class="slide" id="constant-lookup-order">
  <h2>Constant lookup order</h2>
  <div>The list of modules searched, in the order searched<br/>
  [Enclosing::Local, Enclosing, Included, Super, Object, Kernel]</div>

    <div class="column left">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module Kernel
  A = B = C = D = E = F = "from kernel"
end

A = B = C = D = E = "from toplevel"

class Super
  A = B = C = D = "from superclass"
end

module Included
  A = B = C = "from included module"
end
]]>
	</script>
  </div>
    <div class="column right">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module Enclosing
  A = B = "from enclosing module"

  class Local  Super
    include Included

    A = "defined locally"

    puts A  # "defined locally"
    puts B  # "from enclosing module"
    puts C  # "from included module"
    puts D  # "from superclass"
    puts E  # "from toplevel"
    puts F  # "from kernel"
  end
end
]]>
	</script>
  </div>
</section>

<section class="slide" id="inheritance">
	<h2>Inheritance</h2>
	<div>
        One of the most important concepts in object-oriented programming is that of inheritance. Ruby does not support Multiple level of inheritances but Ruby supports mixins. A mixin is like a specialized implementation of multiple inheritance in which only the interface portion is inherited.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[

class MyClass
  def my_method
    'my_method ()'
  end
end

class MySubClass < MyClass
end


obj = MySubClass.new
obj.my_method()       # => 'my_method ()'


MySubClass.ancestors
# => [MySubClass, MyClass, Object, Kernel, BasicObject]
]]>
	</script>
  </div>
</section>

<section class="slide" id="inheritance-scheme">
	<h2>Inheritance</h2>
    <div class="row">
      <img src="support/themes/style/images/basic_object.png" alt="Inheritance scheme">
  </div>
</section>

<section class="slide" id="self">
	<h2>Discovering self</h2>
	<div>
	Every line of Ruby code is executed inside an object—the so–called current object. The <i>current object</i> is also known as <strong>self</strong>, because you can access it with the <strong>self</strong> keyword.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def testing_self
    @var = 10     # An instance variable of self

    my_method()
    self        # Same as self.my_method()
  end

  def my_method
    @var = @var + 1
  end
end

obj = MyClass.new
obj.testing_self  # => #&lt;MyClass:0x510b44 @var=11&gt;
]]>
	</script>
  </div>
</section>

<section class="slide" id="self-contexts">
	<h2>self in different contexts</h2>
    <div class="row">
      <img src="support/themes/style/images/self.png" alt="self">
  </div>
</section>

<section class="slide" id="self-access">
	<h2>Access modifiers and self</h2>
	<div>
	When calling methods accessing <strong>self</strong>, the object is accessed from kind of outside, and only public and protected methods are available.
	</div>
    <div class="row">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class C
  def public_method
    self.private_method
  end

  private

  def private_method
  end
end
]]>
	</script>
      <script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
C.new.public_method
# => NoMethodError: private method `private_method` called for #&lt;C:0x00..>
]]>
	</script>
  </div>
</section>

<section class="slide" id="methods-lookup-order">
	<h2>The rules of method lookup</h2>
	<div>
        There are three different kinds of methods containers in Ruby: Classes, Modules and Singleton Classes. When a method is invoked all of them are searched for the first matching method to execute. When the objects gets a message, it looks for a corresponding method in the following order:
	</div>
    <div class="row">
    <ul>
      <li class="slide">In singleton class</li>
      <li>Its class</li>
      <li>Modules mixed into its class, in reverse order of inclusion</li>
      <li>The class's superclass</li>
      <li>Modules mixed into the superclass, in reverse order of inclusion</li>
      <li>Likewise, up to Object (and its mix-in Kernel) and BasicObject</li>
    </ul>
  </div>
</section>

<section class="slide" id="method-lookup-chain">
	<h2>Method lookup chain example</h2>
    <div class="column left">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module Printable
  def print
    puts "Printable::print"
  end
  def prepare_cover
    puts "Printable::prepare_cover"
  end
end

module Document
  def print_to_screen
    puts "Document::print_to_screen"
    prepare_cover
    format_for_screen
    print
  end
  def format_for_screen
    puts "Document::format_for_screen"
  end
  def print
    puts "Document::print"
  end
end
]]>
	</script>
  </div>
     <div class="column right">
      <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Book
  include Document
  include Printable
end


b = Book.new
b.print_to_screen
]]>
	</script>
	<script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
# => Document::print_to_screen
# => Printable::prepare_cover
# => Document::format_for_screen
# => Printable::print
]]>
	</script>
</section>

<section class="slide" id="meth-lookup">
	<h2>Method lookup chain example</h2>
    <div class="row">
      <img src="support/themes/style/images/basic_object_loockup.png" alt="self">
  </div>
</section>

<section class="slide" id="calling-methods-dynamically">
	<h2>Calling methods dynamically</h2>
	<div>The most common way for dynamic method calling is to send   a message to object.</div><br/><br/>
	<script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA["hi there".send(:length)  #=> 8]]>
	</script>
  <br/>
  <div>A Method object represents a chunk of code and a context in which it executes. Once we have our Method object, we can execute it sometime later by sending it the message call.</div>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
method_object = "hi there".method(:length)
method_object.call  #=> 8  ]]>
  </script>
  <br/>
  <div>Or just eval</div>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[eval "'hi there'.length"  #=> 8]]>
  </script>
  <br/>
  <div>Instantiating a method object is the fastest dynamic way in calling a method, eval is the slowest one. Also when sending a message to an object, or when instantiating a method object, you can call private methods of that object.</div>
</section>

<section class="slide" id="defining-methods-dynamically">
	<h2>Defining methods dynamically</h2>
  <div>You can define a method on the spot with <i>define_method()</i>. You just need to provide a method name and a block, which becomes the method body.</div>

  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass

  define_method :triple do |my_arg|
    my_arg * 3
  end

end

obj = MyClass.new
obj.triple(2)
# => 6

  ]]>
  </script>
</section>

<section class="slide" id="undefining-methods">
	<h2>Undefining methods</h2>
  <div>A method can be undefined any time, as well as defined.</div>

  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def meth1; "meth1 called"; end
  def meth2; "meth2 called"; end
  def meth3; "meth3 called"; end
end

obj = MyClass.new      # => #&lt;MyClass:0x9170850>
obj.meth1              # => "meth1 called"
  ]]>
  </script>
  <br/>
    <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  undef meth1
  remove_method :meth2
  undef_method :meth3
end

obj.meth1              # => NoMethodError
obj.meth2              # => NoMethodError
obj.meth3              # => NoMethodError
  ]]>
  </script>
</section>

<section class="slide" id="undefining-class">
	<h2>Undefining class</h2>

  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
Object.send(:remove_const, :MyClass)

obj = MyClass.new    # => NameError: unitialized constant
  ]]>
  </script>
</section>

<section class="slide" id="method-missing">
	<h2>Method missing</h2>
	<div>When you send a message to an object, the object executes the first method it finds on its method lookup path with the same name as the message. If it fails to find any such method, it end up with <strong>method_missing</strong> method, where a NoMethodError exception is raised unless you have provided other behavior for it. The method_missing method is passed the symbol of the non-existent method, an array of the arguments that were passed in the original call and any block passed to the original method.</div>

    <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Person
  def method_missing (meth, *args, &block)
    if met.to_s =~ /^find_all_by_(\w+)$/
      "Looking for the Person"
    else
      super
    end
  end
end
  ]]>
  </script>
</section>


<section class="slide" id="respond-to">
	<h2>Method missing</h2>
	<div>When defining dynamic methods with <strong>method_missing</strong>, the good practice is to add the same behavior to <strong>respond_to?</strong></div>

    <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Person
  def method_missing(meth, *args, &block)
    if meth.to_s =~ /^find_by_(.+)$/
      'looking for the Person'
    else
      super
    end
  end

  def respond_to?(meth)
    if meth.to_s =~ /^find_by_.*$/ then true else super end
  end
end
  ]]>
  </script>
  <br>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
#   -> person.find_by_name
#   -> person.find_by_age
#   -> person.find_by_id
  ]]>
  </script>
</section>

<section class="slide" id="instance-variables">
	<h2>Class and Instance variables</h2>
	<div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Polygon
  @@sides = 10
  def self.sides
    @@sides
  end
end

puts Polygon.sides # => 10
  ]]>
  </script>
</div>
	<div class="column right">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Polygon
  attr_reader :sides

  def initialize(sides)
    @sides = sides
  end
end

puts Polygon.sides # => NoMethodError
puts Polygon.new(10).sides # => 10  ]]>
  </script>
</div>
</section>

<section class="slide" id="instance-variable-meths">
	<h2 class="not-capitalized">instance_variable_get(), instance_variable_set(),
instance_variable_defined?()
</h2>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def initialize(p1, p2)
    @a, @b = p1, p2
  end
end

c = MyClass.new('aaa', 'bbb')
puts c.instance_variable_get(:@a)			# => "aaa"
puts c.instance_variable_set(:@a, "dog")	# => "dog"
puts c.instance_variable_get(:@a)			# => "dog"
puts c.instance_variable_set(:@c, "cat")	# => "cat"
puts c.instance_variable_defined?(:@c)		# => true
puts c.instance_variable_get(:@c)			# => "cat"
  ]]>
  </script>
</div>
</section>

<section class="slide" id="scope">
	<h2>Scope</h2>
	<div>Scope defines where in a program a variable is accessible. Scope changes whenever the program enters (or exits) a class or module definition or a method. These three borders are marked by the keywords <strong>class, module,</strong> and <strong>def</strong>, respectively. Each of these keywords acts like a Scope&nbsp;Gate.</div>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[v1 = 1

class MyClass
  v2 = 2
  local_variables   # => [:v2]

  def my_method
    v3 = 3
    local_variables
  end

  local_variables   # => [:v2]
end

obj = MyClass.new
obj.my_method       # => [:v3]
local_variables     # => [:v1, :obj]  ]]>
  </script>
</div>
</section>

<section class="slide" id="blocks-locals">
	<h2>Blocks and local variables</h2>
	<div>Blocks behave like closures, they capture the scope they are defined at.</div>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
      	def my_method
      	  yield
      	end

      	top_level_variable = 1

      	my_method do
      	  top_level_variable += 1
      	  local_to_block = 1
      	end

      	top_level_variable		# => 2
      	local_to_block 			# => Error!
]]>
  </script>
</div>
</section>

<section class="slide" id="scope-gate">
	<h2>Blocks and local variables</h2>
	<div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
        my_var = 'Success!'

      	class MyClass
      	  puts "#{my_var} in class definition"

      	  def my_method
      	    puts "#{my_var} in the method"
      	  end
      	end

      	MyClass.new.my_method
]]>
  </script>
<br/>
  <script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
      undefined local variable or method
      `my_var` for MyClass::Class (NameError)]]>
  </script>
</div>

<div class="column right slide">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
        my_var = 'Success'

      	MyClass = Class.new do
      	  puts "#{my_var} in class definition"

      	  define_method :my_method do
      	    puts "#{my_var} in the method"
      	  end
      	end

      	MyClass.new.my_method
]]>
  </script>
<br/>
  <script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
      Success in class definition
      Success in the method
      ]]>
  </script>
</div>
</section>

<section class="slide" id="define-methods">
	<h2>Methods with shared variable</h2>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def define_methods
  shared = 0

  Kernel.send :define_method, :counter do
    shared
  end

  Kernel.send :define_method, :inc do |x|
    shared += x
  end
end

define_methods
puts counter 		# => 0
inc(4)
puts counter 		# => 4
      ]]>
  </script>
</div>
</section>

<section class="slide" id="binding">
	<h2>Binding</h2>
	<div>In Ruby current binding can be captured, and any code can be evaluated in that captured scope, any time.</div>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def local_with_binding(bind)
  bind.eval("local")
end

def my_meth
  local = "local from the inside"
  local_with_binding(binding)
end

local = "top level local"

puts local_with_binding(binding)			# => "top level local"
puts my_meth 								# => "local from the inside"
      ]]>
  </script>
</div>
</section>

<section class="slide" id="instance-eval">
	<h2 class="not-capitalized">instance_eval and instance_exec</h2>
	<div><strong>instance_eval</strong> method evaluates a string containing Ruby source code, or the given block, within the context of the receiver (obj).</div>
	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[class MyClass
  def initialize
    @v = 1
  end
end

obj = MyClass.new
obj.instance_eval do
  self    # => #<MyClass:0x3340dc @v=1>
  @v      # => 1
end
      ]]>
  </script>
<br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
v=2
obj.instance_eval { @v = v }
obj.instance_eval { @v }		# => 2

obj.instance_exec(3) { |multiplier| @v * multiplier } # => 6

      ]]>
  </script>
</div>
</section>

<section class="slide" id="class-eval">
	<h2>Class eval</h2>
	<div><strong>class_eval</strong> (also known by its alternate name, <strong>module_eval</strong>) evaluates a block in the context of an existing class.<.div>

	<div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def add_method_to(a_class)
  a_class.class_eval do
    def m; 'Hello!' ; end
  end
end

add_method_to String
"abc".m   # => "Hello!"
      ]]>
  </script>
</div>
</section>

<section class="slide" id="blocks">
  <h2 class="not-capitalized">Understanding Ruby Blocs, Procs, Lambdas, Methods</h2>
  <img src="support/themes/style/images/surprise.png" alt="What do you know about procs?">
</section>

<section class="slide" id="blocks1">
  <h2 class="not-capitalized">So, what is going on here?</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
array = [1, 2, 3, 4]

array.collect! do |n|
  n ** 2
end

puts array.inspect

# => [1, 4, 9, 16]
      ]]>
  </script>
</div>

<ol>
  <li>First, we send the collect! method to an Array with a block of code.</li>
  <li>The code block interacts with a variable used within the collect! method (n in this case) and squares it.</li>
  <li>Each element inside the array is now squared.</li>
</ol>
</section>

<section class="slide" id="blocks2">
  <h2>Block</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Array
  def iterate!
    self.each_with_index do |n, i|
      self[i] = yield(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate! do |n|
  n ** 2
end

puts array.inspect

# => [1, 4, 9, 16]
      ]]>
</script>
</div>
</section>

<section class="slide" id="to-proc">
  <h2 class="not-capitalized">Convert the block to a Proc</h2>

  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Array
  def iterate!(&code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate! do |n|
  n ** 2
end

puts array.inspect

# => [1, 4, 9, 16]
      ]]>
  </script>
</div>

  <div class="column right">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def what_am_i(&block)
  block.class
end

puts what_am_i {}

# => Proc
      ]]>
  </script>
</div>
</section>

<section class="slide" id="procs">
  <h2 class="not-capitalized">Procedures, AKA, Procs</h2>
  <div>The only difference between blocks and Procs is that a block is a Proc that cannot be saved, and as such, is a one time use solution.</div>

  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Array
  def iterate!(code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

array_1 = [1, 2, 3, 4]
array_2 = [2, 3, 4, 5]

square = Proc.new do |n|
  n ** 2
end

      ]]>
  </script>
</div>

  <div class="column right">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[

array_1.iterate!(square)
array_2.iterate!(square)

puts array_1.inspect
puts array_2.inspect

# => [1, 4, 9, 16]
# => [4, 9, 16, 25]
  </script>
</div>
</section>

<section class="slide" id="callbacks">
  <h2>callbacks</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def callbacks(procs)
  procs[:starting].call

  puts "Still going"

  procs[:finishing].call
end

callbacks(:starting => Proc.new { puts "Starting" },
          :finishing => Proc.new { puts "Finishing" })

# => Starting
# => Still going
# => Finishing
      ]]>
</script>
</div>
</section>

<section class="slide" id="bloc-proc">
  <h2 class="not-capitalized">So, when should you use blocks over Procs?</h2>

<ul>
  <li>Block: Your method is breaking an object down into smaller pieces, and you want to let your users interact with these pieces.</li>
  <li>Block: You want to run multiple expressions atomically, like a database migration.</li>
  <li>Proc: You want to reuse a block of code multiple times.</li>
  <li>Proc: Your method will have one or more callbacks.</li>
</ul>
</section>

<section class="slide" id="lambdas">
  <h2>Lambdas</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Array
  def iterate!(code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

array = [1, 2, 3, 4]

array.iterate!(lambda { |n| n ** 2 })

puts array.inspect

# => [1, 4, 9, 16]
      ]]>
</script>
</div>
</section>

<section class="slide" id="lambdas-args">
  <h2 class="not-capitalized">Lambdas check the number of arguments</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def args(code)
  one, two = 1, 2
  code.call(one, two)
end

args(Proc.new{|a, b, c| puts "Give me a #{a} and a #{b} and a #{c.class}"})

args(lambda{|a, b, c| puts "Give me a #{a} and a #{b} and a #{c.class}"})

# => Give me a 1 and a 2 and a NilClass
# *.rb:8: ArgumentError: wrong number of arguments (2 for 3) (ArgumentError)
      ]]>
</script>
</div>
</section>

<section class="slide" id="lambdas-returns">
  <h2 class="not-capitalized">Lambdas have lesser returns</h2>

  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def proc_return
  Proc.new { return "Proc.new"}.call
  return "proc_return method finished"
end

def lambda_return
  lambda { return "lambda" }.call
  return "lambda_return method finished"
end

puts proc_return
puts lambda_return

# => Proc.new
# => lambda_return method finished
      ]]>
</script>
</div>
</section>

<section class="slide" id="lambdas-returns2">
  <h2 class="not-capitalized">Lambdas have lesser returns</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def generic_return(code)
  code.call
  return "generic_return method finished"
end

puts generic_return(Proc.new { return "Proc.new" })
puts generic_return(lambda { return "lambda" })

# => *.rb:6: unexpected return (LocalJumpError)
# => generic_return method finished
      ]]>
</script>
</div>
</section>

<section class="slide" id="generic-return">
  <h2 class="not-capitalized">Lambdas have lesser returns</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def generic_return(code)
  one, two    = 1, 2
  three, four = code.call(one, two)
  return "Give me a #{three} and a #{four}"
end

puts generic_return(lambda { |x, y| return x + 2, y + 2 })

puts generic_return(Proc.new { |x, y| return x + 2, y + 2 })

puts generic_return(Proc.new { |x, y| x + 2; y + 2 })

puts generic_return(Proc.new { |x, y| [x + 2, y + 2] })

# => Give me a 3 and a 4
# => *.rb:9: unexpected return (LocalJumpError)
# => Give me a 4 and a 
# => Give me a 3 and a 4
      ]]>
</script>
</div>
</section>

<section class="slide" id="methods">
  <h2 class="not-capitalized">Method Objects</h2>
  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class Array
  def iterate!(code)
    self.each_with_index do |n, i|
      self[i] = code.call(n)
    end
  end
end

def square(n)
  n ** 2
end

array = [1, 2, 3, 4]

array.iterate!(method(:square))

puts array.inspect

# => [1, 4, 9, 16]
      ]]>
</script>
</div>

<div class="column right">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
def square(n)
  n ** 2
end

puts method(:square).class

# => Method
      ]]>
</script>
</div>
</section>

<section class="slide" id="methods-binding">
  <h2 class="not-capitalized">Method Objects binding</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def initialize(value)
    @x = value
  end

  def my_method
    @x
  end
end

object = MyClass.new(1)
m = object.method(:my_method)
m.call                    # => 1

unbound = m.unbind
another_object = MyClass.new(2)
m = unbound.bind(another_object)
m.call                    # => 2
      ]]>
</script>
</div>
</section>

<section class="slide" id="conclusion">
  <h2>Conclusion</h2>

<ul>
  <li>blocks and Procs act like code snippets</li>
  <li>lambdas and Methods act like methods</li>
</ul>
</section>

<section class="slide" id="singleton">
  <h2>Singleton Methods</h2>
  <div>A Singleton method is a method which belongs to a single object rather than to an entire class and other objects.</div>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
str = "Just a regular string"

def str.title?
  self.upcase == self
end

str.title?                 # => false
str.methods.grep /title?/  # => ["title?"]
str.singleton_methods      # => ["title?"]
      ]]>
</script>
</div>
</section>

<section class="slide" id="eigenclass">
  <h2>Anonymous class or Eigenclass</h2>

  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
rocky = Dog.new
snoopy = Dog.new
def snoopy.alter_ego
  "Red Baron"
end

snoopy.alter_ego      # => "Red Baron"
rocky.alter_ego
# => NoMethodError: undefined method 
# `alter_ego` for #<Dog:0x000000190ce0>
      ]]>
</script>
</div>

<div class="column right">
  <img src="support/themes/style/images/eigenclass_method_lookup.gif" alt="metakoans.rb">
</div>
</section>

<section class="slide" id="runtime">
  <h2 class="not-capitalized">Runtime introspection</h2>
  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def my_method
    @v = 1
    my_private
  end

  private
  def my_private
    caller
  end
end

obj = MyClass.new
def obj.singleton; "i'm singleton"; end
      ]]>
</script>
</div>

<div class="column right" style="width: 55%; margin-left: -5px">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
obj.my_method # => ["test.rb:4:in `my_method`",
              # "test.rb:16:in `<top>`", ... ]

obj.class     # => MyClass
obj.methods.grep /my/  # => [:my_method]
obj.private_methods    # => [:my_private, :irb...]
obj.instance_variables # => [:@v]
obj.singleton_methods  # => [:singleton]

MyClass.instance_methods(false) # => [:my_method]
local_variables                 # => [:obj]

MyClass.instance_methods == obj.methods # => true
MyClass.methods == obj.Methods          # => false
      ]]>
</script>
</div>
</section>

<section class="slide" id="class-macros">
  <h2>class macros</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  attr_accessor :my_attribute
end

class MyClass
  def my_attribute
    @my_attribute
  end

  def my_attribute= val
    @my_attribute = val
  end
end

obj = MyClass.new
obj.my_attribute = 5
obj.my_attribute    # => 5
      ]]>
</script>
</div>
</section>

<section class="slide" id="class-syntax">
  <h2>class methods syntax</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def self.my_method; end
end
      ]]>
  </script>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass.my_other_method; end
      ]]>
  </script>
  <br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  class << self
    def my_method; end
  end
end
      ]]>
  </script>
</div>
</section>

<section class="slide" id="class-attrs">
  <h2>class attributes</h2>
  <div class="column left">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass; end
class Class
  attr_accessor :c
end

MyClass.c = 'It works!'
MyClass.c               # => 'It works!'
      ]]>
</script>
<br/>
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  class << self
    attr_accessor :c
  end
end

MyClass.c = 'It works!'
MyClass.c               # => 'It works!'
      ]]>
</script>
</div>

<div class="column right">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass; end

def MyClass.c= val
  @c = val
end

def MyClass.c
  @c
end

MyClass.c = 'It works!'
MyClass.c             # => 'It works!'
      ]]>
</script>
</div>
</section>

<section class="slide" id="module">
  <h2>module trouble</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module MyModule
  def self.my_method; 'hello'; end
end

class MyClass
  include MyModule
end

MyClass.my_method      # => NoMethodError!
      ]]>
  </script>
</div>
<div class="row slide">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module MyModule
  def self.my_method; 'hello'; end
end

class MyClass
  class << seld
    include MyModule
  end
end

MyClass.my_method      # => 'hello'
MyClass.singleton_methods # => [:my_method]
      ]]>
  </script>
</div>
</section>

<section class="slide" id="extend">
  <h2 class="not-capitalized">Object#extend</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module MyModule
  def self.my_method; 'hello'; end
end

obj = Object.new
obj.extend Module
obj.my_method     # => 'hello'

class MyClass
  extend MyModule
end

MyClass.my_method      # => 'hello'
      ]]>
  </script>
</div>
</section>

<section class="slide" id="alias">
  <h2>Method aliases</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class MyClass
  def my_method; 'my_method'; end
  alias :m :my_method
end

obj = MyClass.new
obj.my_method     # => 'my_method'
obj.m             # => 'my_method'

class MyClass
  alias_method :m2, :m
end
obj.m2            # => 'my_method'
      ]]>
  </script>
</div>
</section>

<section class="slide" id="refefine-aliased">
  <h2 class="not-capitalized">What happens if you alias a method and then redefine it?</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class String
  alias :real_length :length

  def length
    real_length > 5 ? 'long' : 'short'
  end
end

"War and Peace".real_length   # => 13
"War and Peace".length        # => 'long'
      ]]>
  </script>
</div>
</section>

<section class="slide" id="hooks">
  <h2>Hook methods</h2>
  <div class="column left" style="width: 55%">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
class String
  def self.inherited(subclass)
    puts "#{self} was inherited by #{subclass}"
  end
end

class MyStrin < String; end

module M
  def self.included(othermod)
    puts "M was mixed in #{othermod}"
  end

  def self.method_added(method)
    puts "New method: M##{method}"
  end

  def my_method; end
end

class C; include M; end
      ]]>
  </script>
</div>

<div class="column right" style="width: 40%">
  <script type="syntaxhighlighter" class="brush: bash">
      <![CDATA[
>> ruby test.rb

String was inherited by MyString
New method: M#my_method
M was mixed into C
      ]]>
  </script>
</div>
</section>

<section class="slide" id="class-instance">
  <h2 class="not-capitalized">Class plus instance methods</h2>
  <div class="row">
  <script type="syntaxhighlighter" class="brush: ruby">
      <![CDATA[
module MyMixin

  def self.included(base)
    base.extend ClassMethods
  end

  def x
    "x()"
  end

  module ClassMethods
    def y
      "y()"
    end
  end
  
end

class C; include MyMixin; end

C.new.x         # => x()
C.y             # => y()
      ]]>
  </script>
</div>
</section>

<section class="slide" id="homework">
  <h2>hometask</h2>
  <img src="support/themes/style/images/metakoans.png" alt="metakoans.rb">
</section>

<!-- End slides. -->


<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="support/javascripts/jquery-1.7.2.min.js"></script>
<script src="support/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="support/core/deck.core.js"></script>
<script src="support/extensions/hash/deck.hash.js"></script>
<script src="support/extensions/menu/deck.menu.js"></script>
<script src="support/extensions/goto/deck.goto.js"></script>
<script src="support/extensions/status/deck.status.js"></script>
<script src="support/extensions/navigation/deck.navigation.js"></script>
<script src="support/extensions/scale/deck.scale.js"></script>

<!-- Syntax highlighter -->
<script src="support/extensions/syntax-highlighter/XRegExp.js"></script>
<script src="support/extensions/syntax-highlighter/shCore.js"></script>
<script src="support/extensions/syntax-highlighter/shBrushRuby.js"></script>
<script src="support/extensions/syntax-highlighter/shBrushBash.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
		SyntaxHighlighter.all();
	});
</script>
</body>
</html>
